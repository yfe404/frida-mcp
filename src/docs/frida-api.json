{
  "version": "17.6.2",
  "sections": [
    {
      "id": "getting-started",
      "title": "Getting started",
      "category": "Other",
      "content": "## Getting started\n\nTo be more productive, we highly recommend using our **[TypeScript](https://www.typescriptlang.org/)**\nbindings. This means you get code completion, type checking, inline docs,\nrefactoring tools, etc.\n\nHere's a short teaser video showing the editor experience:\n\n[![Frida TypeScript demo](https://i.ytimg.com/vi/9cr4gOPFN4o/sddefault.jpg)](https://youtu.be/9cr4gOPFN4o)\n\nClone **[this repo](https://github.com/oleavr/frida-agent-example)** to get started.",
      "keywords": [
        "Getting",
        "started"
      ],
      "examples": []
    },
    {
      "id": "runtime-information",
      "title": "Runtime information",
      "category": "Runtime",
      "content": "## Runtime information\n\n### Frida\n\n+   `Frida.version`: property containing the current Frida version, as a string.\n\n+   `Frida.heapSize`: dynamic property containing the current size of Frida's\n    private heap, shared by all scripts and Frida's own runtime. This is useful\n    for keeping an eye on how much memory your instrumentation is using out of\n    the total consumed by the hosting process.\n\n### Script\n\n+   `Script.runtime`: string property containing the runtime being used.\n    Either `QJS` or `V8`.\n\n+   `Script.evaluate(name, source)`: evaluates the given JavaScript string\n    `source` in the global scope, where `name` is a string specifying the\n    script's name, e.g. `/plugins/tty.js`. The provided name is a UNIX-style\n    virtual filesystem path used in future stack traces.\n    {: #script-evaluate}\n\n    Useful for agents that want to support loading user-provided scripts inside\n    their own script. The two benefits over simply using `eval()` is that the\n    script filename can be provided, and source maps are supported — both\n    inline and through\n    [`Script.registerSourceMap()`](#script-registersourcemap).\n\n    Returns the resulting value of the evaluated code.\n\n+   `Script.load(name, source)`: compiles and evaluates the given JavaScript\n    string `source` as an ES module, where `name` is a string specifying the\n    module's name, e.g. `/plugins/screenshot.js`. The provided name is a\n    UNIX-style virtual filesystem path used in future stack traces, and is\n    visible to other modules, which may import it, either statically or\n    dynamically.\n\n    Useful for agents that want to support loading user-provided scripts inside\n    their own script. This API offers the same benefits over `eval()` as\n    [`Script.evaluate()`](#script-evaluate), in addition to encapsulating the\n    user-provided code in its own ES module. This means values may be exported,\n    and subsequently imported by other modules. The parent script may also\n    export values that can be imported from the loaded child script. This\n    requires that the parent uses the new ES module bundle format used by newer\n    versions of frida-compile.\n\n    Returns a *Promise* that resolves to the module's namespace object.\n\n+   `Script.registerSourceMap(name, json)`: registers a source map for the\n    specified script `name`, given as a string with a UNIX-style virtual\n    filesystem path, e.g. `/plugins/screenshot.js`. The source map `json` is a\n    string containing the raw JSON representation of the source map.\n    {: #script-registersourcemap}\n\n    Should ideally be called before the given script gets loaded, so stack\n    traces created during load can make use of the source map.\n\n+   `Script.nextTick(func[, ...params])`: runs `func` on the next tick, i.e.\n    when the current native thread exits the JavaScript runtime. Any additional\n    `params` are passed to it.\n\n+   `Script.pin()`: temporarily prevents the current script from being unloaded.\n    This is reference-counted, so there must be one matching *unpin()* happening\n    at a later point. Typically used in the callback of *bindWeak()* when you\n    need to schedule cleanup on another thread.\n\n+   `Script.unpin()`: reverses a previous *pin()* so the current script may be\n    unloaded.\n\n+   `Script.bindWeak(value, fn)`: monitors `value` and calls the `fn` callback\n    as soon as `value` has been garbage-collected, or the script is about to get\n    unloaded. Returns an ID that you can pass to [`Script.unbindWeak()`](#unbindweak)\n    for explicit cleanup.\n    {: #bindweak}\n\n    This API is useful if you're building a language-binding, where you need to\n    free native resources when a JS value is no longer needed.\n\n+   `Script.unbindWeak(id)`: stops monitoring the value passed to\n    `Script.bindWeak(value, fn)`, and call the `fn` callback immediately.\n    {: #unbindweak}\n\n+   `Script.setGlobalAccessHandler(handler | null)`: installs or uninstalls a\n    handler that is used to resolve attempts to access non-existent global\n    variables. Useful for implementing a REPL where unknown identifiers may be\n    fetched lazily from a database.\n\n    The `handler` is an object containing two properties:\n\n    -   `enumerate()`: queries which additional globals exist. Must return an\n                       array of strings.\n    -   `get(property)`: retrieves the value for the given property.\n\n---",
      "keywords": [
        "Script.evaluate",
        "eval",
        "Script.registerSourceMap",
        "Script.load",
        "Script.nextTick",
        "Script.pin",
        "unpin",
        "bindWeak",
        "Script.unpin",
        "pin",
        "Script.bindWeak",
        "Script.unbindWeak",
        "Script.setGlobalAccessHandler",
        "enumerate",
        "get",
        "Runtime",
        "information"
      ],
      "examples": []
    },
    {
      "id": "process-thread-module-and-memory",
      "title": "Process, Thread, Module and Memory",
      "category": "Process, Thread, Module and Memory",
      "content": "## Process, Thread, Module and Memory\n\n### Process\n\n+   `Process.id`: property containing the PID as a number\n\n+   `Process.arch`: property containing the string `ia32`, `x64`, `arm`\n    or `arm64`\n    {: #process-arch}\n\n+   `Process.platform`: property containing the string `windows`, `darwin`,\n    `linux`, `freebsd`, `qnx`, or `barebone`\n\n+   `Process.pageSize`: property containing the size of a virtual memory page\n    (in bytes) as a number. This is used to make your scripts more portable.\n    {: #process-pagesize}\n\n+   `Process.pointerSize`: property containing the size of a pointer\n    (in bytes) as a number. This is used to make your scripts more portable.\n    {: #process-pointersize}\n\n+   `Process.codeSigningPolicy`: property containing the string `optional` or\n    `required`, where the latter means Frida will avoid modifying existing code\n    in memory and will not try to run unsigned code. Currently this property\n    will always be set to `optional` unless you are using **[Gadget](/docs/gadget)**\n    and have configured it to assume that code-signing is required. This\n    property allows you to determine whether the **[Interceptor](#interceptor)** API\n    is off limits, and whether it is safe to modify code or run unsigned code.\n\n+   `Process.mainModule`: property containing a [`Module`](#module) representing\n    the main executable of the process\n\n+   `Process.getCurrentDir()`: returns a string specifying the filesystem path\n    to the current working directory\n\n+   `Process.getHomeDir()`: returns a string specifying the filesystem path to\n    the current user's home directory\n\n+   `Process.getTmpDir()`: returns a string specifying the filesystem path to\n    the directory to use for temporary files\n\n+   `Process.isDebuggerAttached()`: returns a boolean indicating whether a\n    debugger is currently attached\n\n+   `Process.getCurrentThreadId()`: get this thread's OS-specific id as a number\n\n+   `Process.enumerateThreads()`: enumerates running threads, returning an array\n    of **[Thread](#thread)** objects.\n    {: #process-enumeratethreads}\n\n+   `Process.attachThreadObserver(callbacks)`: starts observing threads, calling\n     the provided `callbacks` as threads are added, removed, and renamed.\n\n    The `callbacks` argument is an object containing one or more of:\n\n    -   `onAdded(thread)`: callback function given the [`Thread`](#thread) that\n        was just added. Called with all existing threads right away, so the\n        initial state vs. updates can be managed easily without worrying about\n        race conditions. When called with a brand new thread, the call happens\n        synchronously from that new thread.\n\n    -   `onRemoved(thread)`: callback function given the [`Thread`](#thread)\n        that was just removed, i.e. is about to terminate. The call happens\n        synchronously from the thread that is about to terminate.\n\n    -   `onRenamed(thread, previousName)`: callback function given the\n        [`Thread`](#thread) that was just renamed, with its new `name` property,\n        and a second argument `previousName` that specifies its previous name.\n        The previous name is either a string, or `null` if the thread was\n        previously unnamed.\n\n    Note that the [`Thread`](#thread) objects lack the `state` and `context`\n    properties, as those are highly volatile in nature, and their changes are\n    not observed. Note that you can combine this API with [`Stalker`](#stalker)\n    to trace the execution of individual threads.\n\n    Returns an observer object that you can call `detach()` on.\n\n+   `Process.runOnThread(id, callback)`: runs the JavaScript function `callback`\n    without any arguments, on the thread specified by `id`. Returns a *Promise*\n    that receives the value returned by your callback.\n\n    Must be used with extreme caution due to the thread potentially being\n    interrupted in non-reentrant code. For example, you could be interrupting it\n    while it's in the middle of some delicate code, holding a specific\n    non-recursive lock, which you then try to implicitly acquire again when you\n    call some function.\n\n+   `Process.findModuleByAddress(address)`,\n    `Process.getModuleByAddress(address)`,\n    `Process.findModuleByName(name)`,\n    `Process.getModuleByName(name)`:\n    returns a **[Module](#module)** whose *address* or *name* matches the one\n    specified. In the event that no such module could be found, the\n    *find*-prefixed functions return *null* whilst the *get*-prefixed functions\n    throw an exception.\n    {: #process-getmodulebyname}\n\n+   `Process.enumerateModules()`: enumerates modules loaded right now, returning\n    an array of **[Module](#module)** objects.\n    {: #process-enumeratemodules}\n\n+   `Process.attachModuleObserver(callbacks)`: starts observing modules, calling\n     the provided `callbacks` as modules are added and removed.\n\n    The `callbacks` argument is an object containing one or more of:\n\n    -   `onAdded(module)`: callback function given the [`Module`](#module) that\n        was just added. Called with all existing modules right away, so the\n        initial state vs. updates can be managed easily without worrying about\n        race conditions. When called with a brand new module, the call happens\n        synchronously right after that module has been loaded, but before the\n        application has had a chance to use it. This means it's a good time to\n        apply your instrumentation, using e.g. [`Interceptor`](#interceptor).\n\n    -   `onRemoved(module)`: callback function given the [`Module`](#module)\n        that was just removed, i.e. unloaded.\n\n    Returns an observer object that you can call `detach()` on.\n\n+   `Process.findRangeByAddress(address)`, `getRangeByAddress(address)`:\n    return an object with details about the range containing *address*. In the\n    event that no such range could be found, *findRangeByAddress()* returns\n    *null* whilst *getRangeByAddress()* throws an exception.  See\n    [`Process.enumerateRanges()`](#process-enumerateranges) for details about which\n    fields are included.\n\n+   `Process.enumerateRanges(protection|specifier)`: enumerates memory ranges\n    satisfying `protection` given as a string of the form: `rwx`, where `rw-`\n    means \"must be at least readable and writable\". Alternatively you may\n    provide a `specifier` object with a `protection` key whose value is as\n    aforementioned, and a `coalesce` key set to `true` if you'd like neighboring\n    ranges with the same protection to be coalesced (the default is `false`;\n    i.e. keeping the ranges separate). Returns an array of objects containing\n    the following properties:\n    {: #process-enumerateranges}\n\n    -   `base`: base address as a [`NativePointer`](#nativepointer)\n    -   `size`: size in bytes\n    -   `protection`: protection string (see above)\n    -   `file`: (when available) file mapping details as an object\n        containing:\n\n        -   `path`: full filesystem path as a string\n        -   `offset`: offset in the mapped file on disk, in bytes\n        -   `size`: size in the mapped file on disk, in bytes\n\n+   `Process.enumerateMallocRanges()`: just like [`enumerateRanges()`](#process-enumerateranges),\n    but for individual memory allocations known to the system heap.\n\n+   `Process.setExceptionHandler(callback)`: install a process-wide exception\n    handler callback that gets a chance to handle native exceptions before the\n    hosting process itself does. Called with a single argument, `details`, that\n    is an object containing:\n    {: #process-setexceptionhandler}\n\n    -   `type`: string specifying one of:\n        * abort\n        * access-violation\n        * guard-page\n        * illegal-instruction\n        * stack-overflow\n        * arithmetic\n        * breakpoint\n        * single-step\n        * system\n    -   `address`: address where the exception occurred, as a **[NativePointer](#nativepointer)**\n    -   `memory`: if present, is an object containing:\n        -   `operation`: the kind of operation that triggered the exception, as\n            a string specifying either `read`, `write`, or `execute`\n        -   `address`: address that was accessed when the exception occurred, as\n            a **[NativePointer](#nativepointer)**\n    -   `context`: object with the keys `pc` and `sp`, which are\n        **[NativePointer](#nativepointer)** objects specifying EIP/RIP/PC and\n        ESP/RSP/SP, respectively, for ia32/x64/arm. Other processor-specific keys\n        are also available, e.g. `eax`, `rax`, `r0`, `x0`, etc.\n        You may also update register values by assigning to these keys.\n    -   `nativeContext`: address of the OS and architecture-specific CPU context\n        struct, as a **[NativePointer](#nativepointer)**. This is only exposed as a\n        last resort for edge-cases where `context` isn't providing enough details. We\n        would however discourage using this and rather submit a pull-request to add\n        the missing bits needed for your use-case.\n\n    It is up to your callback to decide what to do with the exception. It could\n    log the issue, notify your application through a **[send()](#communication-send)**\n    followed by a blocking recv() for acknowledgement of the sent data being received,\n    or it can modify registers and memory to recover from the exception. You should\n    return `true` if you did handle the exception, in which case Frida will\n    resume the thread immediately. If you do not return `true`, Frida will\n    forward the exception to the hosting process' exception handler, if it has\n    one, or let the OS terminate the process.\n\n\n### Thread\n\nObjects returned by e.g.\n[`Process.enumerateThreads()`](#process-enumeratethreads).<br/><br/>\n\n-   `id`: OS-specific id, as a number\n\n-   `name`: string specifying the thread's name, if available\n\n-   `state`: snapshot of the thread's state, as a string specifying either\n    `running`, `stopped`, `waiting`, `uninterruptible`, or `halted`\n\n-   `context`: snapshot of CPU registers, as an object with the keys `pc` and\n    `sp`, which are **[NativePointer](#nativepointer)** objects specifying\n    EIP/RIP/PC and ESP/RSP/SP, respectively, for ia32/x64/arm. Other\n    processor-specific keys are also available, e.g. `eax`, `rax`, `r0`, `x0`,\n    etc.\n    {: #thread-context}\n\n-   `entrypoint`: where the thread started its execution, if applicable and\n    available. When present, it's an object containing:\n\n    -   `routine`: the thread's start routine, as a\n        [`NativePointer`](#nativepointer)\n\n    -   `parameter`: parameter passed to `routine`, if available, as a\n        [`NativePointer`](#nativepointer)\n\n-   `setHardwareBreakpoint(id, address)`: sets a hardware breakpoint, where `id`\n    is a number specifying the breakpoint ID, and `address` is a\n    [`NativePointer`](#nativepointer) specifying the address of the breakpoint.\n    Typically used in conjunction with\n    [`Process.setExceptionHandler()`](#process-setexceptionhandler) to handle\n    the raised exceptions.\n    {: #thread-sethardwarebreakpoint}\n\n-   `unsetHardwareBreakpoint(id)`: unsets a hardware breakpoint, where `id`\n    is a number specifying the breakpoint ID previously set by calling\n    [`setHardwareBreakpoint()`](#thread-sethardwarebreakpoint).\n\n-   `setHardwareWatchpoint(id, address, size, conditions)`: sets a harware\n    watchpoint, where `id` is a number specifying the watchpoint ID, `address`\n    is a [`NativePointer`](#nativepointer) specifying the address of the region\n    to be watched, `size` is a number specifying the size of that region, and\n    `conditions` is a string specifying either `r`, `w`, or `rw`. Here, `r`\n    means to watch for reads, `w` means to watch for writes, and `rw` means to\n    watch for both reads and writes.\n    Typically used in conjunction with\n    [`Process.setExceptionHandler()`](#process-setexceptionhandler) to handle\n    the raised exceptions.\n    {: #thread-sethardwarewatchpoint}\n\n-   `unsetHardwareWatchpoint(id)`: unsets a hardware watchpoint, where `id` is a\n    number specifying the watchpoint ID previously set by calling\n    [`setHardwareWatchpoint()`](#thread-sethardwarewatchpoint).\n\n+   `Thread.backtrace([context, backtracer])`: generate a backtrace for the\n    current thread, returned as an array of [`NativePointer`](#nativepointer) objects.\n    {: #thread-backtrace}\n\n    If you call this from Interceptor's [`onEnter`](#interceptor-onenter) or\n    [`onLeave`](#interceptor-onleave) callbacks you\n    should provide `this.context` for the optional `context` argument, as it\n    will give you a more accurate backtrace. Omitting `context` means the\n    backtrace will be generated from the current stack location, which may\n    not give you a very good backtrace due to the JavaScript VM's stack frames.\n    The optional `backtracer` argument specifies the kind of backtracer to use,\n    and must be either `Backtracer.FUZZY` or `Backtracer.ACCURATE`, where the\n    latter is the default if not specified. The accurate kind of backtracers\n    rely on debugger-friendly binaries or presence of debug information to do a\n    good job, whereas the fuzzy backtracers perform forensics on the stack in\n    order to guess the return addresses, which means you will get false\n    positives, but it will work on any binary. The generated backtrace is\n    currently limited to 16 frames and is not adjustable without recompiling\n    Frida.\n\n{% highlight js %}\nconst commonCrypto = Process.getModuleByName('libcommonCrypto.dylib');\nconst f = commonCrypto.getExportByName('CCCryptorCreate');\nInterceptor.attach(f, {\n  onEnter(args) {\n    console.log('CCCryptorCreate called from:\\n' +\n        Thread.backtrace(this.context, Backtracer.ACCURATE)\n        .map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n  }\n});\n{% endhighlight %}\n\n+   `Thread.sleep(delay)`: suspend execution of the current thread for `delay`\n    seconds specified as a number. For example 0.05 to sleep for 50 ms.\n\n\n### Module\n\nObjects returned by e.g. [`Module.load()`](#module-load) and [`Process.enumerateModules()`](#process-enumeratemodules).<br/><br/>\n\n-   `name`: canonical module name as a string\n\n-   `base`: base address as a [`NativePointer`](#nativepointer)\n\n-   `size`: size in bytes\n\n-   `path`: full filesystem path as a string\n\n-   `ensureInitialized()`: ensures that the module initializers have been run.\n    This is important during early instrumentation, i.e. run early in the\n    process lifetime, to be able to safely interact with APIs. One such use-case\n    is interacting with **[ObjC](#objc)** classes provided by a given module.\n\n-   `enumerateImports()`: enumerates imports of module, returning an array of\n    objects containing the following properties:\n\n    -   `type`: string specifying either `function` or `variable`\n    -   `name`: import name as a string\n    -   `module`: module name as a string\n    -   `address`: absolute address as a [`NativePointer`](#nativepointer)\n    -   `slot`: memory location where the import is stored, as a\n        [`NativePointer`](#nativepointer)\n\n    Only the `name` field is guaranteed to be present for all imports. The\n    platform-specific backend will do its best to resolve the other fields\n    even beyond what the native metadata provides, but there is no guarantee\n    that it will succeed.\n\n-   `enumerateExports()`: enumerates exports of module, returning an array\n    of objects containing the following properties:\n\n    -   `type`: string specifying either `function` or `variable`\n    -   `name`: export name as a string\n    -   `address`: absolute address as a [`NativePointer`](#nativepointer)\n\n-   `enumerateSymbols()`: enumerates symbols of module, returning an array of\n    objects containing the following properties:\n\n    -   `isGlobal`: boolean specifying whether symbol is globally visible\n    -   `type`: string specifying one of:\n        -   unknown\n        -   section\n        -   undefined (Mach-O)\n        -   absolute (Mach-O)\n        -   prebound-undefined (Mach-O)\n        -   indirect (Mach-O)\n        -   object (ELF)\n        -   function (ELF)\n        -   file (ELF)\n        -   common (ELF)\n        -   tls (ELF)\n    -   `section`: if present, is an object containing:\n        -   `id`: string containing section index, segment name (if\n                  applicable) and section name – same format as\n                  [r2][]'s section IDs\n        -   `protection`: protection like in [`Process.enumerateRanges()`](#process-enumerateranges)\n    -   `name`: symbol name as a string\n    -   `address`: absolute address as a [`NativePointer`](#nativepointer)\n    -   `size`: if present, a number specifying the symbol's size in bytes\n\n<div class=\"note info\">\n  <h5>enumerateSymbols() is only available on i/macOS and Linux-based OSes</h5>\n  <p markdown=\"1\">\n    We would love to support this on the other platforms too, so if you find\n    this useful and would like to help out, please get in touch. You may also\n    find the **[DebugSymbol](#debugsymbol)** API adequate, depending on your use-case.\n  </p>\n</div>\n\n-   `enumerateRanges(protection)`: just like [`Process.enumerateRanges`](#process-enumerateranges),\n    except it's scoped to the module.\n\n-   `enumerateSections()`: enumerates sections of module, returning an array of\n    objects containing the following properties:\n\n    -   `id`: string containing section index, segment name (if\n              applicable) and section name – same format as\n              [r2][]'s section IDs\n    -   `name`: section name as a string\n    -   `address`: absolute address as a [`NativePointer`](#nativepointer)\n    -   `size`: size in bytes\n\n-   `enumerateDependencies()`: enumerates dependencies of module, returning an\n    array of objects containing the following properties:\n\n    -   `name`: module name as a string\n    -   `type`: string specifying one of:\n        -   regular\n        -   weak\n        -   reexport\n        -   upward\n\n-   `findExportByName(name)`,\n    `getExportByName(name)`: returns the absolute address of the export named\n    `name`. In the event that no such export could be found, the *find*-prefixed\n    function returns *null* whilst the *get*-prefixed function throws an\n    exception.\n    {: #module-getexportbyname}\n\n-   `findSymbolByName(name)`,\n    `getSymbolByName(name)`: returns the absolute address of the symbol named\n    `name`. In the event that no such symbol could be found, the *find*-prefixed\n    function returns *null* whilst the *get*-prefixed function throws an\n    exception.\n\n+   `Module.load(path)`: loads the specified module from the filesystem path\n    and returns a [`Module`](#module) object. Throws an exception if the specified\n    module cannot be loaded.\n    {: #module-load}\n\n+   `Module.findGlobalExportByName(name)`,\n    `Module.getGlobalExportByName(name)`: returns the absolute address of the\n    global export named `name`. This can be a costly search and should be\n    avoided. In the event that no such export could be found, the\n    *find*-prefixed function returns *null* whilst the *get*-prefixed function\n    throws an exception.\n\n\n### ModuleMap\n\n+   `new ModuleMap([filter])`: create a new module map optimized for determining\n    which module a given memory address belongs to, if any. Takes a snapshot of\n    the currently loaded modules when created, which may be refreshed by calling\n    [`update()`](#modulemap-update). The `filter` argument is optional and allows\n    you to pass a function used for filtering the list of modules. This is useful if\n    you e.g. only care about modules owned by the application itself, and allows you\n    to quickly check if an address belongs to one of its modules. The `filter`\n    function is passed a **[Module](#module)** object and must return `true` for\n    each module that should be kept in the map. It is called for each loaded\n    module every time the map is updated.\n\n-   `has(address)`: check if `address` belongs to any of the contained modules,\n    and returns the result as a boolean\n\n-   `find(address)`, `get(address)`: returns a **[Module](#module)** with details\n    about the module that `address` belongs to. In the event that no such module\n    could be found, `find()` returns `null` whilst `get()` throws an exception.\n    {: #modulemap-find}\n\n-   `findName(address)`,\n    `getName(address)`,\n    `findPath(address)`,\n    `getPath(address)`:\n    just like [`find()`](#modulemap-find) and [`get()`](#modulemap-find), but only\n    returns the `name` or `path` field, which means less overhead when you don't need\n    the other details.\n\n-   `update()`: update the map. You should call this after a module has been\n    loaded or unloaded to avoid operating on stale data.\n    {: #modulemap-update}\n\n-   `values()`: returns an array with the **[Module](#module)** objects currently in\n    the map. The returned array is a deep copy and will not mutate after a call\n    to [`update()`](#modulemap-update).\n\n\n### Memory\n\n+   `Memory.scan(address, size, pattern, callbacks)`: scan memory for\n    occurrences of `pattern` in the memory range given by `address` and `size`.\n    {: #memory-scan}\n\n    -   `pattern` must be of the form \"13 37 ?? ff\" to match 0x13 followed by\n        0x37 followed by any byte followed by 0xff.\n        For more advanced matching it is also possible to specify an\n        [r2][]-style mask. The mask is bitwise AND-ed against both the needle\n        and the haystack. To specify the mask append a `:` character after the\n        needle, followed by the mask using the same syntax.\n        For example: \"13 37 13 37 : 1f ff ff f1\".\n        For convenience it is also possible to specify nibble-level wildcards,\n        like \"?3 37 13 ?7\", which gets translated into masks behind the scenes.\n\n    -   `callbacks` is an object with:\n\n        -   `onMatch(address, size)`: called with `address` containing the\n            address of the occurence as a [`NativePointer`](#nativepointer) and\n            `size` specifying the size as a number.\n\n            This function may return the string `stop` to cancel the memory\n            scanning early.\n\n        -   `onError(reason)`: called with `reason` when there was a memory\n            access error while scanning\n\n        -   `onComplete()`: called when the memory range has been fully scanned\n\n-   `Memory.scanSync(address, size, pattern)`: synchronous version of [`scan()`](#memory-scan)\n    that returns an array of objects containing the following properties:\n\n    -   `address`: absolute address as a [`NativePointer`](#nativepointer).\n    -   `size`: size in bytes\n\n    For example:\n\n{% highlight js %}\n// Find the module for the program itself, always at index 0:\nconst m = Process.enumerateModules()[0];\n\n// Or load a module by name:\n//const m = Module.load('win32u.dll');\n\n// Print its properties:\nconsole.log(JSON.stringify(m));\n\n// Dump it from its base address:\nconsole.log(hexdump(m.base));\n\n// The pattern that you are interested in:\nconst pattern = '00 00 00 00 ?? 13 37 ?? 42';\n\nMemory.scan(m.base, m.size, pattern, {\n  onMatch(address, size) {\n    console.log('Memory.scan() found match at', address,\n        'with size', size);\n\n    // Optionally stop scanning early:\n    return 'stop';\n  },\n  onComplete() {\n    console.log('Memory.scan() complete');\n  }\n});\n\nconst results = Memory.scanSync(m.base, m.size, pattern);\nconsole.log('Memory.scanSync() result:\\n' +\n    JSON.stringify(results));\n{% endhighlight %}\n\n+   `Memory.alloc(size[, options])`: allocate `size` bytes of memory on the\n    heap, or, if `size` is a multiple of\n    [`Process.pageSize`](#process-pagesize), one or more raw memory pages\n    managed by the OS. When using page granularity you may also specify an\n    `options` object if you need the memory allocated close to a given address,\n    by specifying `{ near: address, maxDistance: distanceInBytes }`.\n    The returned value is a [`NativePointer`](#nativepointer) and the underlying\n    memory will be released when all JavaScript handles to it are gone. This\n    means you need to keep a reference to it while the pointer is being used by\n    code outside the JavaScript runtime.\n    {: #memory-alloc}\n\n+   `Memory.copy(dst, src, n)`: just like memcpy(). Returns nothing.\n    {: #memory-copy}\n\n    - dst: a [`NativePointer`](#nativepointer) specifying the destination base address.\n    - src: a [`NativePointer`](#nativepointer) specifying the source base address.\n    - n: size in bytes to be copied.\n\n+   `Memory.dup(address, size)`: short-hand for [`Memory.alloc()`](#memory-alloc)\n    followed by [`Memory.copy()`](#memory-copy). Returns a [`NativePointer`](#nativepointer)\n    containing the base address of the freshly allocated memory. See [`Memory.copy()`](#memory-copy)\n    for details on the memory allocation's lifetime.\n\n+   `Memory.protect(address, size, protection)`: update protection on a region\n    of memory, where `protection` is a string of the same format as\n    [`Process.enumerateRanges()`](#process-enumerateranges).\n\n    Returns a boolean indicating whether the operation completed successfully.\n\n    For example:\n\n{% highlight js %}\nMemory.protect(ptr('0x1234'), 4096, 'rw-');\n{% endhighlight %}\n\n+   `Memory.queryProtection(address)`: determines the current protection of the\n    memory at `address`, specified as a **[NativePointer](#nativepointer)**.\n    Returns a page protection string of the same format as\n    [`Process.enumerateRanges()`](#process-enumerateranges).\n\n+   `Memory.patchCode(address, size, apply)`: safely modify `size` bytes at\n    `address`, specified as a **[NativePointer](#nativepointer)**. The supplied\n    JavaScript function `apply` gets called with a writable pointer where you must\n    write the desired modifications before returning. Do not make any assumptions\n    about this being the same location as `address`, as some systems require\n    modifications to be written to a temporary location before being mapped into\n    memory on top of the original memory page (e.g. on iOS, where directly modifying\n    in-memory code may result in the process losing its CS_VALID status).\n    {: #memory-patchcode}\n\n    For example:\n\n{% highlight js %}\nconst gameEngine = Process.getModuleByName('game-engine.so');\nconst getLivesLeft = gameEngine.getExportByName('get_lives_left');\nconst maxPatchSize = 64; // Do not write out of bounds, may be a temporary buffer!\nMemory.patchCode(getLivesLeft, maxPatchSize, code => {\n  const cw = new X86Writer(code, { pc: getLivesLeft });\n  cw.putMovRegU32('eax', 9000);\n  cw.putRet();\n  cw.flush();\n});\n{% endhighlight %}\n\n+   `Memory.allocUtf8String(str)`,\n    `Memory.allocUtf16String(str)`,\n    `Memory.allocAnsiString(str)`:\n    allocate, encode and write out `str` as a UTF-8/UTF-16/ANSI string on the\n    heap. The returned object is a [`NativePointer`](#nativepointer). See\n    [`Memory.alloc()`](#memory-alloc) for details about its lifetime.\n\n\n### MemoryAccessMonitor\n\n+   `MemoryAccessMonitor.enable(ranges, callbacks)`: monitor one or more memory\n    ranges for access, and notify on the first access of each contained memory\n    page. `ranges` is either a single range object or an array of such objects,\n    each of which contains:\n    {: #memoryaccessmonitor-enable}\n\n    -   `base`: base address as a [`NativePointer`](#nativepointer)\n    -   `size`: size in bytes\n\n    `callbacks` is an object specifying:\n\n    -   `onAccess(details)`: called synchronously with `details` object\n        containing:\n        -   `threadId`: the ID of the thread performing the access, as a number.\n        -   `operation`: the kind of operation that triggered the access, as a\n            string specifying either `read`, `write`, or `execute`\n        -   `from`: address of instruction performing the access as a\n            [`NativePointer`](#nativepointer)\n        -   `address`: address being accessed as a [`NativePointer`](#nativepointer)\n        -   `rangeIndex`: index of the accessed range in the ranges provided to\n            `MemoryAccessMonitor.enable()`\n        -   `pageIndex`: index of the accessed memory page inside the specified\n            range\n        -   `pagesCompleted`: overall number of pages which have been accessed\n            so far (and are no longer being monitored)\n        -   `pagesTotal`: overall number of pages that were initially monitored\n        -   `context`: CPU registers, just like\n            [`Thread#context`](#thread-context). You may also update register\n            values by assigning to these keys.\n\n+   `MemoryAccessMonitor.disable()`: stop monitoring the remaining memory ranges\n    passed to [`MemoryAccessMonitor.enable()`](#memoryaccessmonitor-enable).\n\n\n### CModule\n\n+   `new CModule(code[, symbols, options])`: creates a new C module from the\n    provided `code`, either a string containing the C source code to compile, or\n    an ArrayBuffer containing a precompiled shared library. The C module gets\n    mapped into memory and becomes fully accessible to JavaScript.\n\n    Useful for implementing hot callbacks, e.g. for **[Interceptor](#interceptor)**\n    and **[Stalker](#stalker)**, but also useful when needing to start new threads\n    in order to call functions in a tight loop, e.g. for fuzzing purposes.\n\n    Global functions are automatically exported as **[NativePointer](#nativepointer)**\n    properties named exactly like in the C source code. This means you can pass them\n    to **[Interceptor](#interceptor)** and **[Stalker](#stalker)**, or call them\n    using **[NativePointer](#nativepointer)**.\n\n    In addition to accessing a curated subset of Gum, GLib, and standard C APIs,\n    the code being mapped in can also communicate with JavaScript through the\n    `symbols` exposed to it. This is the optional second argument, an object\n    specifying additional symbol names and their\n    **[NativePointer](#nativepointer)** values, each of which will be plugged in\n    at creation. This may for example be one or more memory blocks allocated\n    using **[Memory.alloc()](#memory-alloc)**, and/or\n    **[NativeCallback](#nativecallback)** values for receiving callbacks from\n    the C module.\n\n    To perform initialization and cleanup, you may define functions with the\n    following names and signatures:\n\n    -   `void init (void)`\n    -   `void finalize (void)`\n\n    Note that all data is read-only, so writable globals should be declared\n    *extern*, allocated using e.g. **[Memory.alloc()](#memory-alloc)**, and passed\n    in as symbols through the constructor's second argument.\n\n    The optional third argument, `options`, is an object that may be used to\n    specify which toolchain to use, e.g.: `{ toolchain: 'external' }`. Supported\n    values are:\n\n    -   `internal`: use TinyCC, which is statically linked into the runtime.\n        Never touches the filesystem and works even in sandboxed processes. The\n        generated code is however not optimized, as TinyCC optimizes for small\n        compiler footprint and short compilation times.\n    -   `external`: use toolchain provided by the target system, assuming it is\n        accessible to the process we're executing inside.\n    -   `any`: same as `internal` if [`Process.arch`](#process-arch) is\n        supported by TinyCC, and `external` otherwise. This is the default\n        behavior if left unspecified.\n\n-   `dispose()`: eagerly unmaps the module from memory. Useful for short-lived\n    modules when waiting for a future garbage collection isn't desirable.\n\n+   `builtins`: an object specifying builtins present when constructing a\n    CModule from C source code. This is typically used by a scaffolding tool\n    such as `frida-create` in order to set up a build environment that matches\n    what CModule uses. The exact contents depends on the\n    [`Process.arch`](#process-arch) and Frida version, but may look something\n    like the following:\n\n        {\n          defines: {\n            'GLIB_SIZEOF_VOID_P': '8',\n            'G_GINT16_MODIFIER': '\"h\"',\n            'G_GINT32_MODIFIER': '\"\"',\n            'G_GINT64_MODIFIER': '\"ll\"',\n            'G_GSIZE_MODIFIER': '\"l\"',\n            'G_GSSIZE_MODIFIER': '\"l\"',\n            'HAVE_I386': true\n          },\n          headers: {\n            'gum/arch-x86/gumx86writer.h': '…',\n            'gum/gumdefs.h': '…',\n            'gum/guminterceptor.h': '…',\n            'gum/gummemory.h': '…',\n            'gum/gummetalarray.h': '…',\n            'gum/gummetalhash.h': '…',\n            'gum/gummodulemap.h': '…',\n            'gum/gumprocess.h': '…',\n            'gum/gumspinlock.h': '…',\n            'gum/gumstalker.h': '…',\n            'glib.h': '…',\n            'json-glib/json-glib.h': '…',\n            'capstone.h': '…'\n          }\n        }\n\n#### Examples\n\n{% highlight js %}\nconst cm = new CModule(`\n#include <stdio.h>\n\nvoid hello(void) {\n  printf(\"Hello World from CModule\\\\n\");\n}\n`);\n\nconsole.log(JSON.stringify(cm));\n\nconst hello = new NativeFunction(cm.hello, 'void', []);\nhello();\n{% endhighlight %}\n\nWhich you might load using Frida's REPL:\n\n{% highlight sh %}\n$ frida -p 0 -l example.js\n{% endhighlight %}\n\n(The REPL monitors the file on disk and reloads the script on change.)\n\nYou can then type `hello()` in the REPL to call the C function.\n\nFor prototyping we recommend using the Frida REPL's built-in CModule support:\n\n{% highlight sh %}\n$ frida -p 0 -C example.c\n{% endhighlight %}\n\nYou may also add `-l example.js` to load some JavaScript next to it.\nThe JavaScript code may use the global variable named `cm` to access\nthe CModule object, but only after [`rpc.exports.init()`](#rpc-exports) has been\ncalled, so perform any initialization depending on the CModule there. You may\nalso inject symbols by assigning to the global object named `cs`, but this\nmust be done *before* [`rpc.exports.init()`](#rpc-exports) gets called.\n\nHere's an example:\n\n![CModule REPL example](https://pbs.twimg.com/media/EEyxQzwXoAAqoAw?format=jpg&name=small)\n\nMore details on CModule can be found in the **[Frida 12.7 release notes]({{\nsite.baseurl_root }}/news/2019/09/18/frida-12-7-released/)**.\n\n\n### RustModule\n\nCompiles Rust source code to machine code, straight to memory.\n\n+   `new RustModule(code[, symbols, options])`: creates a new Rust module from\n    the provided `code`, a string containing the Rust source code to compile.\n    The Rust module gets mapped into memory and becomes fully accessible to\n    JavaScript.\n\n    Useful for implementing hot callbacks, e.g. for [Interceptor](#interceptor)\n    and [Stalker](#stalker), but also useful when needing to start new threads\n    in order to call functions in a tight loop, e.g. for fuzzing purposes.\n\n    Public functions are automatically exported as\n    [`NativePointer`](#nativepointer) properties. This means you can pass them\n    to Interceptor and Stalker, or call them using\n    [`NativeFunction`](#nativefunction). In such cases you typically want to\n    ensure they are marked `#[no_mangle]` and `extern \"C\"`.\n\n    In addition to Rust libraries, the code being mapped in can also communicate\n    with JavaScript through the `symbols` exposed to it. This object maps symbol\n    names to [`NativePointer`](#nativepointer) values. Declare them as\n    `extern \"C\"` in your Rust source code. This may for example be one or more\n    memory blocks allocated using `Memory.alloc()`, and/or\n    [`NativeCallback`](#nativecallback) values for receiving callbacks from the\n    Rust module.\n\n    The optional third argument, `options`, is an object that may be used to\n    specify which Cargo dependencies to use, e.g.:\n    `{ dependencies: ['base64 = \"0.22.1\"', 'anyhow = \"1.0.97\"'] }`.\n\n\n### ApiResolver\n\n+   `new ApiResolver(type)`: create a new resolver of the given `type`, allowing\n    you to quickly find APIs by name, with globs permitted. Precisely which\n    resolvers are available depends on the current platform and runtimes loaded\n    in the current process. As of the time of writing, the available resolvers\n    are:\n\n    -   `module`: Resolves module exports, imports, and sections.\n                  Always available.\n    -   `swift`: Resolves Swift functions.\n                 Available in processes that have a Swift runtime loaded. Use\n                 `Swift.available` to check at runtime, or wrap your\n                 `new ApiResolver('swift')` call in a *try-catch*.\n    -   `objc`: Resolves Objective-C methods.\n                Available on macOS and iOS in processes that have the Objective-C\n                runtime loaded. Use [`ObjC.available`](#objc-available) to check\n                at runtime, or wrap your `new ApiResolver('objc')` call in a\n                *try-catch*.\n\n    The resolver will load the minimum amount of data required on creation, and\n    lazy-load the rest depending on the queries it receives. It is thus\n    recommended to use the same instance for a batch of queries, but recreate it\n    for future batches to avoid looking at stale data.\n\n-   `enumerateMatches(query)`: performs the resolver-specific `query` string,\n    optionally suffixed with `/i` to perform case-insensitive matching,\n    returning an array of objects containing the following properties:\n\n    -   `name`: name of the API that was found\n    -   `address`: address as a [`NativePointer`](#nativepointer)\n    -   `size`: if present, a number specifying the size in bytes\n\n{% highlight js %}\nconst resolver = new ApiResolver('module');\nconst matches = resolver.enumerateMatches('exports:*!open*');\nconst first = matches[0];\n/*\n * Where `first` is an object similar to:\n *\n * {\n *   name: '/usr/lib/libSystem.B.dylib!opendir$INODE64',\n *   address: ptr('0x7fff870135c9')\n * }\n */\n{% endhighlight %}\n\n{% highlight js %}\nconst resolver = new ApiResolver('module');\nconst matches = resolver.enumerateMatches('sections:*!*text*');\nconst first = matches[0];\n/*\n * Where `first` is an object similar to:\n *\n * {\n *   name: '/usr/lib/libSystem.B.dylib!0.__TEXT.__text',\n *   address: ptr('0x191c1e504'),\n *   size: 1528\n * }\n */\n{% endhighlight %}\n\n{% highlight js %}\nconst resolver = new ApiResolver('swift');\nconst matches = resolver.enumerateMatches('functions:*CoreDevice!*RemoteDevice*');\nconst first = matches[0];\n/*\n * Where `first` is an object similar to:\n *\n * {\n *   name: '/Library/Developer/PrivateFrameworks/CoreDevice.framework/Versions/A/CoreDevice!dispatch thunk of CoreDevice.RemoteDevice.addDeviceInfoChanged(on: __C.OS_dispatch_queue?, handler: (Foundation.UUID, CoreDeviceProtocols.DeviceInfo) -> ()) -> CoreDevice.Invalidatable',\n *   address: ptr('0x1078c3570')\n * }\n */\n{% endhighlight %}\n\n{% highlight js %}\nconst resolver = new ApiResolver('objc');\nconst matches = resolver.enumerateMatches('-[NSURL* *HTTP*]');\nconst first = matches[0];\n/*\n * Where `first` is an object similar to:\n *\n * {\n *   name: '-[NSURLRequest valueForHTTPHeaderField:]',\n *   address: ptr('0x7fff94183e22')\n * }\n */\n{% endhighlight %}\n\n\n### DebugSymbol\n\n+   `DebugSymbol.fromAddress(address)`, `DebugSymbol.fromName(name)`:\n    look up debug information for `address`/`name` and return it as an object\n    containing:\n\n    -   `address`: Address that this symbol is for, as a [`NativePointer`](#nativepointer).\n    -   `name`: Name of the symbol, as a string, or null if unknown.\n    -   `moduleName`: Module name owning this symbol, as a string, or null if\n                      unknown.\n    -   `fileName`: File name owning this symbol, as a string, or null if\n                    unknown.\n    -   `lineNumber`: Line number in `fileName`, as a number, or null if\n                      unknown.\n\n    You may also call `toString()` on it, which is very useful when combined\n    with [`Thread.backtrace()`](#thread-backtrace):\n\n{% highlight js %}\nconst commonCrypto = Process.getModuleByName('libcommonCrypto.dylib');\nconst f = commonCrypto.getExportByName('CCCryptorCreate');\nInterceptor.attach(f, {\n  onEnter(args) {\n    console.log('CCCryptorCreate called from:\\n' +\n        Thread.backtrace(this.context, Backtracer.ACCURATE)\n        .map(DebugSymbol.fromAddress).join('\\n') + '\\n');\n  }\n});\n{% endhighlight %}\n\n+   `DebugSymbol.getFunctionByName(name)`: resolves a function name and\n    returns its address as a [`NativePointer`](#nativepointer). Returns the first if\n    more than one function is found. Throws an exception if the name cannot be\n    resolved.\n\n+   `DebugSymbol.findFunctionsNamed(name)`: resolves a function name and returns\n    its addresses as an array of [`NativePointer`](#nativepointer) objects.\n\n+   `DebugSymbol.findFunctionsMatching(glob)`: resolves function names matching\n    `glob` and returns their addresses as an array of [`NativePointer`](#nativepointer)\n    objects.\n\n+   `DebugSymbol.load(path)`: loads debug symbols for a specific module.\n\n\n### Kernel\n\n+   `Kernel.available`: a boolean specifying whether the Kernel API is\n    available. Do not invoke any other `Kernel` properties or methods unless\n    this is the case.\n\n+   `Kernel.base`: base address of the kernel, as a **[UInt64](#uint64)**.\n\n+   `Kernel.pageSize`: size of a kernel page in bytes, as a number.\n\n+   `Kernel.enumerateModules()`: enumerates kernel modules loaded right now,\n    returning an array of objects containing the following properties:\n\n    -   `name`: canonical module name as a string\n    -   `base`: base address as a [`NativePointer`](#nativepointer)\n    -   `size`: size in bytes\n\n+   `Kernel.enumerateRanges(protection|specifier)`: enumerate kernel memory\n    ranges satisfying `protection` given as a string of the form: `rwx`, where\n    `rw-` means \"must be at least readable and writable\". Alternatively you may\n    provide a `specifier` object with a `protection` key whose value is as\n    aforementioned, and a `coalesce` key set to `true` if you'd like neighboring\n    ranges with the same protection to be coalesced (the default is `false`;\n    i.e. keeping the ranges separate). Returns an array of objects containing\n    the following properties:\n    {: #kernel-enumerateranges}\n\n    -   `base`: base address as a [`NativePointer`](#nativepointer)\n    -   `size`: size in bytes\n    -   `protection`: protection string (see above)\n\n+   `Kernel.enumerateModuleRanges(name, protection)`: just like\n    [`Kernel.enumerateRanges`](#kernel-enumerateranges), except it's scoped to the\n    specified module `name` – which may be `null` for the module of the kernel\n    itself. Each range also has a `name` field containing a unique identifier as a\n    string.\n\n+   `Kernel.alloc(size)`: allocate `size` bytes of kernel memory, rounded up to\n    a multiple of the kernel's page size. The returned value is a [`UInt64`](#uint64)\n    specifying the base address of the allocation.\n\n+   `Kernel.protect(address, size, protection)`: update protection on a region\n    of kernel memory, where `protection` is a string of the same format as\n    [`Kernel.enumerateRanges()`](#kernel-enumerateranges).\n\n    For example:\n\n{% highlight js %}\nKernel.protect(UInt64('0x1234'), 4096, 'rw-');\n{% endhighlight %}\n\n+   `Kernel.readByteArray(address, length)`: just like\n    [`NativePointer#readByteArray`](#nativepointer-readbytearray), but reading from\n    kernel memory.\n\n+   `Kernel.writeByteArray(address, bytes)`: just like\n    [`NativePointer#writeByteArray`](#nativepointer-writebytearray), but writing to\n    kernel memory.\n\n+   `Kernel.scan(address, size, pattern, callbacks)`: just like [`Memory.scan`](#memory-scan),\n    but scanning kernel memory.\n    {: #kernel-scan}\n\n-   `Kernel.scanSync(address, size, pattern)`: synchronous version of [`scan()`](#kernel-scan)\n    that returns the matches in an array.\n\n---",
      "keywords": [
        "page",
        "pointer",
        "Process.getCurrentDir",
        "Process.getHomeDir",
        "Process.getTmpDir",
        "Process.isDebuggerAttached",
        "Process.getCurrentThreadId",
        "Process.enumerateThreads",
        "Process.attachThreadObserver",
        "onAdded",
        "onRemoved",
        "onRenamed",
        "detach",
        "Process.runOnThread",
        "Process.findModuleByAddress",
        "Process.getModuleByAddress",
        "Process.findModuleByName",
        "Process.getModuleByName",
        "Process.enumerateModules",
        "Process.attachModuleObserver",
        "Process.findRangeByAddress",
        "getRangeByAddress",
        "findRangeByAddress",
        "Process.enumerateRanges",
        "coalesced",
        "string",
        "Process.enumerateMallocRanges",
        "enumerateRanges",
        "Process.setExceptionHandler",
        "send",
        "recv",
        "setHardwareBreakpoint",
        "unsetHardwareBreakpoint",
        "setHardwareWatchpoint",
        "unsetHardwareWatchpoint",
        "Thread.backtrace",
        "commonCrypto.getExportByName",
        "Interceptor.attach",
        "onEnter",
        "console.log",
        "map",
        "join",
        "Thread.sleep",
        "Module.load",
        "ensureInitialized",
        "enumerateImports",
        "enumerateExports",
        "enumerateSymbols",
        "undefined",
        "absolute"
      ],
      "examples": []
    },
    {
      "id": "data-types-function-and-callback",
      "title": "Data Types, Function and Callback",
      "category": "Other",
      "content": "## Data Types, Function and Callback\n\n### Int64\n\n+   `new Int64(v)`: create a new Int64 from `v`, which is either a number or a\n    string containing a value in decimal, or hexadecimal if prefixed with \"0x\".\n    You may use the `int64(v)` short-hand for brevity.\n\n-   `add(rhs)`, `sub(rhs)`,\n    `and(rhs)`, `or(rhs)`,\n    `xor(rhs)`:\n    make a new Int64 with this Int64 plus/minus/and/or/xor `rhs`, which may\n    either be a number or another Int64\n\n-   `shr(n)`, `shl(n)`:\n    make a new Int64 with this Int64 shifted right/left by `n` bits\n\n-   `compare(rhs)`: returns an integer comparison result just like\n    **[String#localeCompare()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)**\n\n-   `toNumber()`: cast this Int64 to a number\n\n-   `toString([radix = 10])`: convert to a string of optional radix (defaults to\n    10)\n\n\n### UInt64\n\n+   `new UInt64(v)`: create a new UInt64 from `v`, which is either a number or a\n    string containing a value in decimal, or hexadecimal if prefixed with \"0x\".\n    You may use the `uint64(v)` short-hand for brevity.\n\n-   `add(rhs)`, `sub(rhs)`,\n    `and(rhs)`, `or(rhs)`,\n    `xor(rhs)`:\n    make a new UInt64 with this UInt64 plus/minus/and/or/xor `rhs`, which may\n    either be a number or another UInt64\n\n-   `shr(n)`, `shl(n)`:\n    make a new UInt64 with this UInt64 shifted right/left by `n` bits\n\n-   `compare(rhs)`: returns an integer comparison result just like\n    **[String#localeCompare()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)**\n\n-   `toNumber()`: cast this UInt64 to a number\n\n-   `toString([radix = 10])`: convert to a string of optional radix (defaults to\n    10)\n\n\n### NativePointer\n\n+   `new NativePointer(s)`: creates a new **[NativePointer](#nativepointer)** from the\n    string `s` containing a memory address in either decimal, or hexadecimal if\n    prefixed with '0x'. You may use the `ptr(s)` short-hand for brevity.\n\n-   `isNull()`: returns a boolean allowing you to conveniently check if a\n    pointer is NULL\n\n-   `add(rhs)`, `sub(rhs)`,\n    `and(rhs)`, `or(rhs)`,\n    `xor(rhs)`:\n    makes a new **[NativePointer](#nativepointer)** with this **[NativePointer](#nativepointer)**\n    plus/minus/and/or/xor `rhs`, which may either be a number or another **[NativePointer](#nativepointer)**\n\n-   `shr(n)`, `shl(n)`:\n    makes a new **[NativePointer](#nativepointer)** with this **[NativePointer](#nativepointer)**\n    shifted right/left by `n` bits\n\n-   `not()`: makes a new **[NativePointer](#nativepointer)** with this **[NativePointer](#nativepointer)**'s\n    bits inverted\n\n-   `sign([key, data])`: makes a new **[NativePointer](#nativepointer)** by taking this\n    **[NativePointer](#nativepointer)**'s bits and adding pointer authentication bits,\n    creating a signed pointer. This is a no-op if the current process does not support\n    pointer authentication, returning this **[NativePointer](#nativepointer)** instead\n    of a new value.\n    {: #nativepointer-sign}\n\n    Optionally, `key` may be specified as a string. Supported values are:\n    -   ia: The IA key, for signing code pointers. This is the default.\n    -   ib: The IB key, for signing code pointers.\n    -   da: The DA key, for signing data pointers.\n    -   db: The DB key, for signing data pointers.\n\n    The `data` argument may also be specified as a **[NativePointer](#nativepointer)**/number-like\n    value to provide extra data used for the signing, and defaults to `0`.\n\n-   `strip([key])`: makes a new **[NativePointer](#nativepointer)** by taking this **[NativePointer](#nativepointer)**'s\n    bits and removing its pointer authentication bits, creating a raw pointer.\n    This is a no-op if the current process does not support pointer\n    authentication, returning this **[NativePointer](#nativepointer)** instead of a\n    new value.\n\n    Optionally, `key` may be passed to specify which key was used to sign the\n    pointer being stripped. Defaults to `ia`. (See [`sign()`](#nativepointer-sign)\n    for supported values.)\n\n-   `blend(smallInteger)`: makes a new **[NativePointer](#nativepointer)** by taking\n    this **[NativePointer](#nativepointer)**'s bits and blending them with a constant,\n    which may in turn be passed to [`sign()`](#nativepointer-sign) as `data`.\n\n-   `equals(rhs)`: returns a boolean indicating whether `rhs` is equal to\n    this one; i.e. it has the same pointer value\n\n-   `compare(rhs)`: returns an integer comparison result just like\n    **[String#localeCompare()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)**\n\n-   `toInt32()`: casts this **[NativePointer](#nativepointer)** to a signed 32-bit integer\n\n-   `toString([radix = 16])`: converts to a string of optional radix (defaults\n    to 16)\n\n-   `toMatchPattern()`: returns a string containing a [`Memory.scan()`](#memory-scan)-compatible\n    match pattern for this pointer's raw value\n\n-   `readPointer()`: reads a [`NativePointer`](#nativepointer) from this memory location.\n\n    A JavaScript exception will be thrown if the address isn't readable.\n\n-   `writePointer(ptr)`: writes `ptr` to this memory location.\n\n    A JavaScript exception will be thrown if the address isn't writable.\n\n-   `readS8()`, `readU8()`,\n    `readS16()`, `readU16()`,\n    `readS32()`, `readU32()`,\n    `readShort()`, `readUShort()`,\n    `readInt()`, `readUInt()`,\n    `readFloat()`, `readDouble()`:\n    reads a signed or unsigned 8/16/32/etc. or float/double value from\n    this memory location and returns it as a number.\n\n    A JavaScript exception will be thrown if the address isn't readable.\n\n-   `writeS8(value)`, `writeU8(value)`,\n    `writeS16(value)`, `writeU16(value)`,\n    `writeS32(value)`, `writeU32(value)`,\n    `writeShort(value)`, `writeUShort(value)`,\n    `writeInt(value)`, `writeUInt(value)`,\n    `writeFloat(value)`, `writeDouble(value)`:\n    writes a signed or unsigned 8/16/32/etc. or float/double `value` to this\n    memory location.\n\n    A JavaScript exception will be thrown if the address isn't writable.\n\n-   `readS64()`, `readU64()`,\n    `readLong()`, `readULong()`:\n    reads a signed or unsigned 64-bit, or long-sized, value from this memory\n    location and returns it as an **[Int64](#int64)**/**[UInt64](#uint64)** value.\n\n    A JavaScript exception will be thrown if the address isn't readable.\n\n-   `writeS64(value)`, `writeU64(value)`,\n    `writeLong(value)`, `writeULong(value)`:\n    writes the **[Int64](#int64)**/**[UInt64](#uint64)** `value` to this memory\n    location.\n\n    A JavaScript exception will be thrown if the address isn't writable.\n\n-   `readByteArray(length)`: reads `length` bytes from this memory location, and\n    returns it as an **[ArrayBuffer](#arraybuffer)**. This buffer may be efficiently\n    transferred to your Frida-based application by passing it as the second argument\n    to [`send()`](#communication-send).\n    {: #nativepointer-readbytearray}\n\n    A JavaScript exception will be thrown if any of the `length` bytes read from\n    the address isn't readable.\n\n-   `writeByteArray(bytes)`: writes `bytes` to this memory location, where\n    `bytes` is either an **[ArrayBuffer](#arraybuffer)**, typically returned from\n    `readByteArray()`, or an array of integers between 0 and 255. For example:\n    `[ 0x13, 0x37, 0x42 ]`.\n    {: #nativepointer-writebytearray}\n\n    A JavaScript exception will be thrown if any of the bytes written to\n    the address isn't writable.\n\n-   `readVolatile(length)`, `writeVolatile(bytes)`: just like\n    [`NativePointer#readByteArray`](#nativepointer-readbytearray) and\n    [`NativePointer#writeByteArray`](#nativepointer-writebytearray), but avoid\n    generating a native exception in case the memory is inaccessible. This means\n    that the memory access is slower, due to one or more system calls being\n    involved, but safe to use in situations where our native exception handling\n    fails or is unavailable, and bad access would end up crashing the process.\n    Use this API if you're dumping memory while application threads may be\n    running, or the pointer references memory that may no longer be accessible.\n\n-   `readCString([size = -1])`,\n    `readUtf8String([size = -1])`,\n    `readUtf16String([length = -1])`,\n    `readAnsiString([size = -1])`:\n    reads the bytes at this memory location as an ASCII, UTF-8, UTF-16, or ANSI\n    string. Supply the optional `size` argument if you know the size of the\n    string in bytes, or omit it or specify *-1* if the string is NUL-terminated.\n    Likewise you may supply the optional `length` argument if you know the\n    length of the string in characters.\n\n    A JavaScript exception will be thrown if any of the `size` / `length` bytes\n    read from the address isn't readable.\n\n    Note that `readAnsiString()` is only available (and relevant) on Windows.\n\n-   `writeUtf8String(str)`,\n    `writeUtf16String(str)`,\n    `writeAnsiString(str)`:\n    encodes and writes the JavaScript string to this memory location (with\n    NUL-terminator).\n\n    A JavaScript exception will be thrown if any of the bytes written to\n    the address isn't writable.\n\n    Note that `writeAnsiString()` is only available (and relevant) on Windows.\n\n\n### ArrayBuffer\n\n+   `wrap(address, size)`: creates an ArrayBuffer backed by an existing memory\n    region, where `address` is a [`NativePointer`](#nativepointer) specifying the\n    base address of the region, and `size` is a number specifying its size. Unlike\n    the [`NativePointer`](#nativepointer) read/write APIs, no validation is performed\n    on access, meaning a bad pointer will crash the process.\n\n-   `unwrap()`: returns a [`NativePointer`](#nativepointer) specifying the base\n    address of the ArrayBuffer's backing store. It is the caller's responsibility to\n    keep the buffer alive while the backing store is still being used.\n\n\n### NativeFunction\n\n+   `new NativeFunction(address, returnType, argTypes[, abi])`: create a new\n    NativeFunction to call the function at `address` (specified with a\n    [`NativePointer`](#nativepointer)), where `returnType` specifies the return type,\n    and the `argTypes` array specifies the argument types. You may optionally also\n    specify `abi` if not system default. For variadic functions, add a `'...'`\n    entry to `argTypes` between the fixed arguments and the variadic ones.\n\n    - #### Structs & Classes by Value\n\n        As for structs or classes passed by value, instead of a string provide an\n        array containing the struct's field types following each other. You may nest\n        these as deep as desired for representing structs inside structs. Note that\n        the returned object is also a [`NativePointer`](#nativepointer), and can thus\n        be passed to [`Interceptor#attach`](#interceptor-attach).\n\n        This must match the struct/class exactly, so if you have a struct with three\n        ints, you must pass `['int', 'int', 'int']`.\n\n        For a class that has virtual methods, the first field will be a pointer\n        to **[the vtable](https://en.wikipedia.org/wiki/Virtual_method_table)**.\n\n        For C++ scenarios involving a return value that is larger than\n        [`Process.pointerSize`](#process-pointersize), a typical ABI may expect\n        that a [`NativePointer`](#nativepointer) to preallocated space must be\n        passed in as the first parameter. (This scenario is common in WebKit,\n        for example.)\n\n    - #### Supported Types\n        -   void\n        -   pointer\n        -   int\n        -   uint\n        -   long\n        -   ulong\n        -   char\n        -   uchar\n        -   size_t\n        -   ssize_t\n        -   float\n        -   double\n        -   int8\n        -   uint8\n        -   int16\n        -   uint16\n        -   int32\n        -   uint32\n        -   int64\n        -   uint64\n        -   bool\n\n    - #### Supported ABIs\n        -   default\n        -   Windows 32-bit:\n            -   sysv\n            -   stdcall\n            -   thiscall\n            -   fastcall\n            -   mscdecl\n        - Windows 64-bit:\n            -   win64\n        - UNIX x86:\n            -   sysv\n            -   unix64\n        - UNIX ARM:\n            -   sysv\n            -   vfp\n\n+   `new NativeFunction(address, returnType, argTypes[, options])`: just like\n    the previous constructor, but where the fourth argument, `options`, is an\n    object that may contain one or more of the following keys:\n\n    -   `abi`: same enum as above.\n    -   `scheduling`: scheduling behavior as a string. Supported values are:\n        -   cooperative: Allow other threads to execute JavaScript code while\n                         calling the native function, i.e. let go of the lock\n                         before the call, and re-acquire it afterwards.\n                         This is the default behavior.\n        -   exclusive: Do not allow other threads to execute JavaScript code\n                       while calling the native function, i.e. keep holding the\n                       JavaScript lock.\n                       This is faster but may result in deadlocks.\n    -   `exceptions`: exception behavior as a string. Supported values are:\n        -   steal: If the called function generates a native exception, e.g.\n                   by dereferencing an invalid pointer, Frida will unwind the\n                   stack and steal the exception, turning it into a JavaScript\n                   exception that can be handled. This may leave the application\n                   in an undefined state, but is useful to avoid crashing the\n                   process while experimenting.\n                   This is the default behavior.\n        -   propagate: Let the application deal with any native exceptions that\n                       occur during the function call. (Or, the handler\n                       installed through [`Process.setExceptionHandler()`](#process-setexceptionhandler).)\n    -   `traps`: code traps to be enabled, as a string. Supported values are:\n        -   default: **[Interceptor.attach()](#interceptor-attach)** callbacks will be\n                     called if any hooks are triggered by a function call.\n        -   none: Prevents boths **[Interceptor](#interceptor)** and\n                  **[Stalker](#stalker)** from triggering.\n        -   all: In addition to **[Interceptor](#interceptor)** callbacks, **[Stalker](#stalker)**\n                 may also be temporarily reactivated for the duration of each function\n                 call. This is useful for e.g. measuring code coverage while guiding a\n                 fuzzer, implementing \"step into\" in a debugger, etc.\n                 Note that this is also possible when using the **[Java](#java)**\n                 and **[ObjC](#objc)** APIs, as method wrappers also provide a\n                 `clone(options)` API to create a new method wrapper with custom\n                 NativeFunction options.\n\n\n### NativeCallback\n\n+   `new NativeCallback(func, returnType, argTypes[, abi])`: create a new\n    NativeCallback implemented by the JavaScript function `func`, where\n    `returnType` specifies the return type, and the `argTypes` array specifies\n    the argument types. You may also specify the abi if not system default.\n    See [`NativeFunction`](#nativefunction) for details about supported types and\n    abis. Note that the returned object is also a [`NativePointer`](#nativepointer),\n    and can thus be passed to [`Interceptor#replace`](#interceptor-replace).\n    When using the resulting callback with **[Interceptor.replace()](#interceptor-replace)**,\n    `func` will be invoked with `this` bound to an object with some useful properties,\n    just like the one in **[Interceptor.attach()](#interceptor-attach)**.\n\n\n### SystemFunction\n\n+   `new SystemFunction(address, returnType, argTypes[, abi])`: just like\n    [`NativeFunction`](#nativefunction), but also provides a snapshot of the thread's\n    last error status. The return value is an object wrapping the actual return value\n    as `value`, with one additional platform-specific field named either `errno`\n    (UNIX) or `lastError` (Windows).\n\n+   `new SystemFunction(address, returnType, argTypes[, options])`: same as\n    above but accepting an `options` object like [`NativeFunction`](#nativefunction)'s\n    corresponding constructor.\n\n---",
      "keywords": [
        "Int64",
        "int64",
        "add",
        "sub",
        "and",
        "or",
        "xor",
        "shr",
        "shl",
        "compare",
        "localeCompare",
        "toNumber",
        "toString",
        "radix",
        "UInt64",
        "uint64",
        "NativePointer",
        "ptr",
        "isNull",
        "not",
        "sign",
        "strip",
        "blend",
        "equals",
        "toInt32",
        "toMatchPattern",
        "Memory.scan",
        "readPointer",
        "writePointer",
        "readS8",
        "readU8",
        "readS16",
        "readU16",
        "readS32",
        "readU32",
        "readShort",
        "readUShort",
        "readInt",
        "readUInt",
        "readFloat",
        "readDouble",
        "writeS8",
        "writeU8",
        "writeS16",
        "writeU16",
        "writeS32",
        "writeU32",
        "writeShort",
        "writeUShort",
        "writeInt"
      ],
      "examples": []
    },
    {
      "id": "network",
      "title": "Network",
      "category": "Other",
      "content": "## Network\n\n### Socket\n\n+   `Socket.listen([options])`: open a TCP or UNIX listening socket. Returns a\n    *Promise* that receives a **[SocketListener](#socketlistener)**.\n\n    Defaults to listening on both IPv4 and IPv6, if supported, and binding on\n    all interfaces on a randomly selected TCP port.\n\n    The optional `options` argument is an object that may contain some of the\n    following keys:\n\n    -   `family`: address family as a string. Supported values are:\n        -   unix\n        -   ipv4\n        -   ipv6\n        Defaults to listening on both `ipv4` and `ipv6` if supported.\n    -   `host`: (IP family) IP address as a string. Defaults to all interfaces.\n    -   `port`: (IP family) IP port as a number. Defaults to any available.\n    -   `type`: (UNIX family) UNIX socket type as a string. Supported types are:\n        -   anonymous\n        -   path\n        -   abstract\n        -   abstract-padded\n        Defaults to `path`.\n    -   `path`: (UNIX family) UNIX socket path as a string.\n    -   `backlog`: Listen backlog as a number. Defaults to `10`.\n\n+   `Socket.connect(options)`: connect to a TCP or UNIX server. Returns a\n    *Promise* that receives a **[SocketConnection](#socketconnection)**.\n\n    The `options` argument is an object that should contain some of the\n    following keys:\n\n    -   `family`: address family as a string. Supported values are:\n        -   unix\n        -   ipv4\n        -   ipv6\n        Defaults to an IP family depending on the `host` specified.\n    -   `host`: (IP family) IP address as a string. Defaults to `localhost`.\n    -   `port`: (IP family) IP port as a number.\n    -   `type`: (UNIX family) UNIX socket type as a string. Supported types are:\n        -   anonymous\n        -   path\n        -   abstract\n        -   abstract-padded\n        Defaults to `path`.\n    -   `path`: (UNIX family) UNIX socket path as a string.\n\n+   `Socket.type(handle)`: inspect the OS socket `handle` and return its type\n    as a string which is either `tcp`, `udp`, `tcp6`, `udp6`, `unix:stream`,\n    `unix:dgram`, or `null` if invalid or unknown.\n\n+   `Socket.localAddress(handle)`,\n    `Socket.peerAddress(handle)`:\n    inspect the OS socket `handle` and return its local or peer address, or\n    `null` if invalid or unknown.\n\n    The object returned has the fields:\n\n    -   `ip`: (IP sockets) IP address as a string.\n    -   `port`: (IP sockets) IP port as a number.\n    -   `path`: (UNIX sockets) UNIX path as a string.\n\n\n### SocketListener\n\nAll methods are fully asynchronous and return Promise objects.<br/><br/>\n\n-   `path`: (UNIX family) path being listened on.\n\n-   `port`: (IP family) IP port being listened on.\n\n-   `close()`: close the listener, releasing resources related to it. Once the\n    listener is closed, all other operations will fail. Closing a listener\n    multiple times is allowed and will not result in an error.\n\n-   `accept()`: wait for the next client to connect. The returned *Promise*\n    receives a **[SocketConnection](#socketconnection)**.\n\n\n### SocketConnection\n\nInherits from **[IOStream](#iostream)**.\nAll methods are fully asynchronous and return Promise objects.<br/><br/>\n\n-   `setNoDelay(noDelay)`: disable the Nagle algorithm if `noDelay` is `true`,\n    otherwise enable it. The Nagle algorithm is enabled by default, so it is\n    only necessary to call this method if you wish to optimize for low delay\n    instead of high throughput.\n\n---",
      "keywords": [
        "Socket.listen",
        "Socket.connect",
        "Socket.type",
        "Socket.localAddress",
        "Socket.peerAddress",
        "close",
        "accept",
        "setNoDelay",
        "Network"
      ],
      "examples": []
    },
    {
      "id": "file-and-stream",
      "title": "File and Stream",
      "category": "I/O",
      "content": "## File and Stream\n\n### File\n\n+   `File.readAllBytes(path)`: synchronously read all bytes from the file\n    specified by `path` and return them as an `ArrayBuffer`.\n\n+   `File.readAllText(path)`: synchronously read all text from the file\n    specified by `path` and return it as a string. The file must be UTF-8\n    encoded, and an exception will be thrown if this is not the case.\n\n+   `File.writeAllBytes(path, data)`: synchronously write `data` to the file\n    specified by `path`, where `data` is an `ArrayBuffer`.\n\n+   `File.writeAllText(path, text)`: synchronously write `text` to the file\n    specified by `path`, where `text` is a string. The file will be UTF-8\n    encoded.\n\n+   `new File(filePath, mode)`: open or create the file at `filePath` with\n    the `mode` string specifying how it should be opened. For example `\"wb\"`\n    to open the file for writing in binary mode (this is the same format as\n    `fopen()` from the C standard library).\n\n-   `tell()`: return the current position of the file pointer within the file.\n\n-   `seek(offset[, whence])`: move the file pointer to a new location. `offset`\n    is the position to move to, and `whence` is the starting point for the\n    offset (`File.SEEK_SET` for the beginning of the file, `File.SEEK_CUR` for\n    the current file position, or `File.SEEK_END` for the end of the file).\n\n-   `readBytes([size])`: read and return `size` bytes from the file starting\n    from the current file pointer position as an `ArrayBuffer`. If `size` is not\n    specified, reads until the end of the file from the current position.\n\n-   `readText([size])`: read and return `size` characters from the file starting\n    from the current file pointer position as a string. If `size` is not\n    specified, reads text until the end of the file from the current position.\n    The bytes being read must be UTF-8 encoded, and an exception will be thrown\n    if this is not the case.\n\n-   `readLine()`: read and return the next line as a string. Starts reading from\n    the current file pointer position. The returned line does not include the\n    newline character.\n\n-   `write(data)`: synchronously write `data` to the file, where `data` is\n    either a string or a buffer as returned by [`NativePointer#readByteArray`](#nativepointer-readbytearray)\n\n-   `flush()`: flush any buffered data to the underlying file.\n\n-   `close()`: close the file. You should call this function when you're done\n    with the file unless you are fine with this happening when the object is\n    garbage-collected or the script is unloaded.\n\n\n### IOStream\n\nAll methods are fully asynchronous and return Promise objects.<br/><br/>\n\n-   `input`: the **[InputStream](#inputstream)** to read from.\n\n-   `output`: the **[OutputStream](#outputstream)** to write to.\n\n-   `close()`: close the stream, releasing resources related to it. This will\n    also close the individual input and output streams. Once the stream is\n    closed, all other operations will fail. Closing a stream multiple times is\n    allowed and will not result in an error.\n\n\n### InputStream\n\nAll methods are fully asynchronous and return Promise objects.<br/><br/>\n\n-   `close()`: close the stream, releasing resources related to it. Once the\n    stream is closed, all other operations will fail. Closing a stream multiple\n    times is allowed and will not result in an error.\n\n-   `read(size)`: read up to `size` bytes from the stream. The returned\n    **Promise** receives an **[ArrayBuffer](#arraybuffer)** up to `size` bytes long.\n    End of stream is signalled through an empty buffer.\n\n-   `readAll(size)`: keep reading from the stream until exactly `size` bytes\n    have been consumed. The returned *Promise* receives an **[ArrayBuffer](#arraybuffer)**\n    that is exactly `size` bytes long. Premature error or end of stream results in the\n    *Promise* getting rejected with an error, where the `Error` object has a\n    `partialData` property containing the incomplete data.\n\n\n### OutputStream\n\nAll methods are fully asynchronous and return Promise objects.<br/><br/>\n\n-   `close()`: close the stream, releasing resources related to it. Once the\n    stream is closed, all other operations will fail. Closing a stream multiple\n    times is allowed and will not result in an error.\n\n-   `write(data)`: try to write `data` to the stream. The `data` value is either\n    an **[ArrayBuffer](#arraybuffer)** or an array of integers between 0 and 255. The\n    returned *Promise* receives a *Number* specifying how many bytes of `data` were\n    written to the stream.\n\n-   `writeAll(data)`: keep writing to the stream until all of `data` has been\n    written. The `data` value is either an **[ArrayBuffer](#arraybuffer)** or an array\n    of integers between 0 and 255. Premature error or end of stream results in an\n    error, where the `Error` object has a `partialSize` property specifying how many\n    bytes of `data` were written to the stream before the error occurred.\n\n-   `writeMemoryRegion(address, size)`: try to write `size` bytes to the stream,\n    reading them from `address`, which is a [`NativePointer`](#nativepointer). The\n    returned *Promise* receives a *Number* specifying how many bytes of `data` were\n    written to the stream.\n\n\n### UnixInputStream\n\n(Only available on UNIX-like OSes.)<br/><br/>\n\n+   `new UnixInputStream(fd[, options])`: create a new\n    **[InputStream](#inputstream)** from the specified file descriptor `fd`.\n\n    You may also supply an `options` object with `autoClose` set to `true` to\n    make the stream close the underlying file descriptor when the stream is\n    released, either through `close()` or future garbage-collection.\n\n\n### UnixOutputStream\n\n(Only available on UNIX-like OSes.)<br/><br/>\n\n+   `new UnixOutputStream(fd[, options])`: create a new\n    **[OutputStream](#outputstream)** from the specified file descriptor `fd`.\n\n    You may also supply an `options` object with `autoClose` set to `true` to\n    make the stream close the underlying file descriptor when the stream is\n    released, either through `close()` or future garbage-collection.\n\n\n### Win32InputStream\n\n(Only available on Windows.)<br/><br/>\n\n+   `new Win32InputStream(handle[, options])`: create a new\n    **[InputStream](#inputstream)** from the specified `handle`, which is a Windows\n    *HANDLE* value.\n\n    You may also supply an `options` object with `autoClose` set to `true` to\n    make the stream close the underlying handle when the stream is released,\n    either through `close()` or future garbage-collection.\n\n\n### Win32OutputStream\n\n(Only available on Windows.)<br/><br/>\n\n+   `new Win32OutputStream(handle[, options])`: create a new\n    **[OutputStream](#outputstream)** from the specified `handle`, which is a\n    Windows *HANDLE* value.\n\n    You may also supply an `options` object with `autoClose` set to `true` to\n    make the stream close the underlying handle when the stream is released,\n    either through `close()` or future garbage-collection.",
      "keywords": [
        "File.readAllBytes",
        "File.readAllText",
        "File.writeAllBytes",
        "File.writeAllText",
        "File",
        "mode",
        "fopen",
        "tell",
        "seek",
        "offset",
        "readBytes",
        "readText",
        "readLine",
        "write",
        "flush",
        "close",
        "read",
        "readAll",
        "writeAll",
        "writeMemoryRegion",
        "UnixInputStream",
        "UnixOutputStream",
        "Win32InputStream",
        "Win32OutputStream",
        "and",
        "Stream"
      ],
      "examples": []
    },
    {
      "id": "database",
      "title": "Database",
      "category": "Other",
      "content": "## Database\n\n### SqliteDatabase\n\n+   `SqliteDatabase.open(path[, options])`: opens the SQLite v3 database\n    specified by `path`, a string containing the filesystem path to the\n    database. By default the database will be opened read-write, but you may\n    customize this behavior by providing an `options` object with a property\n    named `flags`, specifying an array of strings containing one or more of the\n    following values: `readonly`, `readwrite`, `create`.  The returned\n    SqliteDatabase object will allow you to perform queries on the database.\n\n+   `SqliteDatabase.openInline(encodedContents)`: just like `open()` but the\n    contents of the database is provided as a string containing its data,\n    Base64-encoded. We recommend gzipping the database before Base64-encoding\n    it, but this is optional and detected by looking for a gzip magic marker.\n    The database is opened read-write, but is 100% in-memory and never touches\n    the filesystem. This is useful for agents that need to bundle a cache of\n    precomputed data, e.g. static analysis data used to guide dynamic analysis.\n    {: #sqlitedatabase-openinline}\n\n-   `close()`: close the database. You should call this function when you're\n    done with the database, unless you are fine with this happening when the\n    object is garbage-collected or the script is unloaded.\n\n-   `exec(sql)`: execute a raw SQL query, where `sql` is a string containing\n    the text-representation of the query. The query's result is ignored, so this\n    should only be used for queries for setting up the database, e.g. table\n    creation.\n\n-   `prepare(sql)`: compile the provided SQL into a\n    **[SqliteStatement](#sqlitestatement)** object, where `sql` is a string\n    containing the text-representation of the query.\n\n    For example:\n\n{% highlight js %}\nconst db = SqliteDatabase.open('/path/to/people.db');\n\nconst smt = db.prepare('SELECT name, bio FROM people WHERE age = ?');\n\nconsole.log('People whose age is 42:');\nsmt.bindInteger(1, 42);\nlet row;\nwhile ((row = smt.step()) !== null) {\n  const [name, bio] = row;\n  console.log('Name:', name);\n  console.log('Bio:', bio);\n}\nsmt.reset();\n{% endhighlight %}\n\n-   `dump()`: dump the database to a gzip-compressed blob encoded as Base64,\n    where the result is returned as a string. This is useful for inlining a\n    cache in your agent's code, loaded by calling [`SqliteDatabase.openInline()`](#sqlitedatabase-openinline).\n\n\n### SqliteStatement\n\n-   `bindInteger(index, value)`: bind the integer `value` to `index`\n-   `bindFloat(index, value)`: bind the floating point `value` to `index`\n-   `bindText(index, value)`: bind the text `value` to `index`\n-   `bindBlob(index, bytes)`: bind the blob `bytes` to `index`, where `bytes`\n    is an **[ArrayBuffer](#arraybuffer)**, array of byte values, or a string\n-   `bindNull(index)`: bind a null value to `index`\n-   `step()`: either start a new query and get the first result, or move to the\n    next one. Returns an array containing the values in the order specified by\n    the query, or `null` when the last result is reached. You should call\n    `reset()` at that point if you intend to use this object again.\n-   `reset()`: reset internal state to allow subsequent queries\n\n---",
      "keywords": [
        "SqliteDatabase.open",
        "SqliteDatabase.openInline",
        "open",
        "close",
        "exec",
        "prepare",
        "db.prepare",
        "console.log",
        "smt.bindInteger",
        "while",
        "smt.step",
        "smt.reset",
        "dump",
        "bindInteger",
        "bindFloat",
        "bindText",
        "bindBlob",
        "bindNull",
        "step",
        "reset",
        "Database"
      ],
      "examples": []
    },
    {
      "id": "instrumentation",
      "title": "Instrumentation",
      "category": "Other",
      "content": "## Instrumentation\n\n### Interceptor\n\n+   `Interceptor.attach(target, callbacks[, data])`: intercept calls to function\n    at `target`. This is a [`NativePointer`](#nativepointer) specifying the address\n    of the function you would like to intercept calls to. Note that on 32-bit ARM this\n    address must have its least significant bit set to 0 for ARM functions, and\n    1 for Thumb functions. Frida takes care of this detail for you if you get\n    the address from a Frida API (for example [`Module#getExportByName()`](#module-getexportbyname)).\n    {: #interceptor-attach}\n\n    The `callbacks` argument is an object containing one or more of:\n\n    -   `onEnter(args)`: callback function given one argument `args` that can be\n        used to read or write arguments as an array of\n        [`NativePointer`](#nativepointer) objects. {: #interceptor-onenter}\n\n    -   `onLeave(retval)`: callback function given one argument `retval` that is\n        a [`NativePointer`](#nativepointer)-derived object containing the raw\n        return value.\n        You may call `retval.replace(1337)` to replace the return value with\n        the integer `1337`, or `retval.replace(ptr(\"0x1234\"))` to replace with\n        a pointer.\n        Note that this object is recycled across *onLeave* calls, so do not\n        store and use it outside your callback. Make a deep copy if you need\n        to store the contained value, e.g.: `ptr(retval.toString())`.\n        {: #interceptor-onleave}\n\n    In case the hooked function is very hot, `onEnter` and `onLeave` may be\n    [`NativePointer`](#nativepointer) values pointing at native C functions compiled\n    using **[CModule](#cmodule)**. Their signatures are:\n\n    -   `void onEnter (GumInvocationContext * ic)`\n\n    -   `void onLeave (GumInvocationContext * ic)`\n\n    In such cases, the third optional argument `data` may be a [`NativePointer`](#nativepointer)\n    accessible through `gum_invocation_context_get_listener_function_data()`.\n\n    You may also intercept arbitrary instructions by passing a function instead\n    of the `callbacks` object. This function has the same signature as\n    `onEnter`, but the `args` argument passed to it will only give you sensible\n    values if the intercepted instruction is at the beginning of a function or\n    at a point where registers/stack have not yet deviated from that point.\n\n    Just like above, this function may also be implemented in C by specifying\n    a [`NativePointer`](#nativepointer) instead of a function.\n\n    Returns a listener object that you can call `detach()` on.\n\n    Note that these functions will be invoked with `this` bound to a\n    per-invocation (thread-local) object where you can store arbitrary data,\n    which is useful if you want to read an argument in `onEnter` and act on it\n    in `onLeave`.\n\n    For example:\n\n{% highlight js %}\nconst libc = Process.getModuleByName('libc.so');\nInterceptor.attach(libc.getExportByName('read'), {\n  onEnter(args) {\n    this.fileDescriptor = args[0].toInt32();\n  },\n  onLeave(retval) {\n    if (retval.toInt32() > 0) {\n      /* do something with this.fileDescriptor */\n    }\n  }\n});\n{% endhighlight %}\n\n+   Additionally, the object contains some useful properties:\n\n    -   `returnAddress`: return address as a **[NativePointer](#nativepointer)**\n\n    -   `context`: object with the keys `pc` and `sp`, which are\n        **[NativePointer](#nativepointer)** objects specifying EIP/RIP/PC and\n        ESP/RSP/SP, respectively, for ia32/x64/arm. Other processor-specific keys\n        are also available, e.g. `eax`, `rax`, `r0`, `x0`, etc.\n        You may also update register values by assigning to these keys.\n\n    -   `errno`: (UNIX) current errno value (you may replace it)\n\n    -   `lastError`: (Windows) current OS error value (you may replace it)\n\n    -   `threadId`: OS thread ID\n\n    -   `depth`: call depth of relative to other invocations\n\n    For example:\n\n{% highlight js %}\nInterceptor.attach(Module.getGlobalExportByName('read'), {\n  onEnter(args) {\n    console.log('Context information:');\n    console.log('Context  : ' + JSON.stringify(this.context));\n    console.log('Return   : ' + this.returnAddress);\n    console.log('ThreadId : ' + this.threadId);\n    console.log('Depth    : ' + this.depth);\n    console.log('Errornr  : ' + this.err);\n\n    // Save arguments for processing in onLeave.\n    this.fd = args[0].toInt32();\n    this.buf = args[1];\n    this.count = args[2].toInt32();\n  },\n  onLeave(result) {\n    console.log('----------')\n    // Show argument 1 (buf), saved during onEnter.\n    const numBytes = result.toInt32();\n    if (numBytes > 0) {\n      console.log(hexdump(this.buf, { length: numBytes, ansi: true }));\n    }\n    console.log('Result   : ' + numBytes);\n  }\n})\n{% endhighlight %}\n\n<div class=\"note\">\n  <h5>Performance considerations</h5>\n  <p>\n    The callbacks provided have a significant impact on performance. If you only\n    need to inspect arguments but do not care about the return value, or the\n    other way around, make sure you omit the callback that you don't need; i.e.\n    avoid putting your logic in <i>onEnter</i> and leaving <i>onLeave</i> in\n    there as an empty callback.\n  </p>\n  <p>\n    On an iPhone 5S the base overhead when providing just <i>onEnter</i> might be\n    something like 6 microseconds, and 11 microseconds with both <i>onEnter</i>\n    and <i>onLeave</i> provided.\n  </p>\n  <p markdown=\"1\">\n    Also be careful about intercepting calls to functions that are called a\n    bazillion times per second; while **[send()](#communication-send)** is\n    asynchronous, the total overhead of sending a single message is not optimized for\n    high frequencies, so that means Frida leaves it up to you to batch multiple values\n    into a single **[send()](#communication-send)**-call, based on whether low delay\n    or high throughput is desired.\n  </p>\n  <p markdown=\"1\">\n    However when hooking hot functions you may use Interceptor in conjunction\n    with **[CModule](#cmodule)** to implement the callbacks in C.\n  </p>\n</div>\n\n+   `Interceptor.detachAll()`: detach all previously attached callbacks.\n\n+   `Interceptor.replace(target, replacement[, data])`: replace function at\n    `target` with implementation at `replacement`. This is typically used if you\n    want to fully or partially replace an existing function's implementation.\n    {: #interceptor-replace}\n\n    Use [`NativeCallback`](#nativecallback) to implement a `replacement` in JavaScript.\n\n    In case the replaced function is very hot, you may implement `replacement`\n    in C using **[CModule](#cmodule)**. You may then also specify the third optional\n    argument `data`, which is a [`NativePointer`](#nativepointer) accessible through\n    `gum_invocation_context_get_listener_function_data()`. Use\n    `gum_interceptor_get_current_invocation()` to get hold of the\n    `GumInvocationContext *`.\n\n    Note that `replacement` will be kept alive until [`Interceptor#revert`](#interceptor-revert) is\n    called.\n\n    If you want to chain to the original implementation you can synchronously\n    call `target` through a [`NativeFunction`](#nativefunction) inside your\n    implementation, which will bypass and go directly to the original implementation.\n\n    Here's an example:\n\n{% highlight js %}\nconst libc = Process.getModuleByName('libc.so');\nconst openPtr = libc.getExportByName('open');\nconst open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);\nInterceptor.replace(openPtr, new NativeCallback((pathPtr, flags) => {\n  const path = pathPtr.readUtf8String();\n  log('Opening \"' + path + '\"');\n  const fd = open(pathPtr, flags);\n  log('Got fd: ' + fd);\n  return fd;\n}, 'int', ['pointer', 'int']));\n{% endhighlight %}\n\n+   `Interceptor.replaceFast(target, replacement)`: like\n    [`replace()`](#interceptor-replace) except `target` is modified to vector\n    directly to your replacement, which means there is less overhead compared to\n    replace(). This also means that you need to use the returned pointer if you\n    want to call the original implementation.\n\n+   `Interceptor.revert(target)`: revert function at `target` to the previous\n    implementation.\n    {: #interceptor-revert}\n\n+   `Interceptor.flush()`: ensure any pending changes have been committed\n    to memory. This is should only be done in the few cases where this is\n    necessary, e.g. if you just **[attach()](#interceptor-attach)**ed to or **[replace()](#interceptor-replace)**d a function that you\n    are about to call using **[NativeFunction](#nativefunction)**. Pending changes\n    are flushed automatically whenever the current thread is about to leave the\n    JavaScript runtime or calls **[send()](#communication-send)**. This includes any\n    API built on top of **[send()](#communication-send)**, like when returning from an\n    **[RPC](#rpc-exports)** method, and calling any method on the **[console](#console)** API.\n\n+   `Interceptor.breakpointKind`: a string specifying the kind of breakpoints to\n    use for non-inline hooks. Only available in the Barebone backend.\n\n    Defaults to 'soft', i.e. software breakpoints. Set it to 'hard' to use\n    hardware breakpoints.\n\n\n### Stalker\n\n+   `Stalker.exclude(range)`: marks the specified memory `range` as excluded,\n    which is an object with `base` and `size` properties – like the properties\n    in an object returned by e.g. [`Process.getModuleByName()`](#process-getmodulebyname).\n\n    This means Stalker will not follow execution when encountering a call to an\n    instruction in such a range. You will thus be able to observe/modify the\n    arguments going in, and the return value coming back, but won't see the\n    instructions that happened between.\n\n    Useful to improve performance and reduce noise.\n\n+   `Stalker.follow([threadId, options])`: start stalking `threadId` (or the\n    current thread if omitted), optionally with `options` for enabling events.\n    {: #stalker-follow}\n\n    For example:\n\n{% highlight js %}\nconst mainThread = Process.enumerateThreads()[0];\n\nStalker.follow(mainThread.id, {\n  events: {\n    call: true, // CALL instructions: yes please\n\n    // Other events:\n    ret: false, // RET instructions\n    exec: false, // all instructions: not recommended as it's\n                 //                   a lot of data\n    block: false, // block executed: coarse execution trace\n    compile: false // block compiled: useful for coverage\n  },\n\n  //\n  // Only specify one of the two following callbacks.\n  // (See note below.)\n  //\n\n  //\n  // onReceive: Called with `events` containing a binary blob\n  //            comprised of one or more GumEvent structs.\n  //            See `gumevent.h` for details about the\n  //            format. Use `Stalker.parse()` to examine the\n  //            data.\n  //\n  //onReceive(events) {\n  //},\n  //\n\n  //\n  // onCallSummary: Called with `summary` being a key-value\n  //                mapping of call target to number of\n  //                calls, in the current time window. You\n  //                would typically implement this instead of\n  //                `onReceive()` for efficiency, i.e. when\n  //                you only want to know which targets were\n  //                called and how many times, but don't care\n  //                about the order that the calls happened\n  //                in.\n  //\n  onCallSummary(summary) {\n  },\n\n  //\n  // Advanced users: This is how you can plug in your own\n  //                 StalkerTransformer, where the provided\n  //                 function is called synchronously\n  //                 whenever Stalker wants to recompile\n  //                 a basic block of the code that's about\n  //                 to be executed by the stalked thread.\n  //\n  //transform(iterator) {\n  //  let instruction = iterator.next();\n  //\n  //  const startAddress = instruction.address;\n  //  const isAppCode = startAddress.compare(appStart) >= 0 &&\n  //      startAddress.compare(appEnd) === -1;\n  //\n  //  /*\n  //   * Need to be careful on ARM/ARM64 as we may disturb instruction sequences\n  //   * that deal with exclusive stores.\n  //   */\n  //  const canEmitNoisyCode = iterator.memoryAccess === 'open';\n  //\n  //  do {\n  //    if (isAppCode && canEmitNoisyCode && instruction.mnemonic === 'ret') {\n  //      iterator.putCmpRegI32('eax', 60);\n  //      iterator.putJccShortLabel('jb', 'nope', 'no-hint');\n  //\n  //      iterator.putCmpRegI32('eax', 90);\n  //      iterator.putJccShortLabel('ja', 'nope', 'no-hint');\n  //\n  //      iterator.putCallout(onMatch);\n  //\n  //      iterator.putLabel('nope');\n  //\n  //      /* You may also use putChainingReturn() to insert an early return. */\n  //    }\n  //\n  //    iterator.keep();\n  //  } while ((instruction = iterator.next()) !== null);\n  //},\n  //\n  // The default implementation is just:\n  //\n  //   while (iterator.next() !== null)\n  //     iterator.keep();\n  //\n  // The example above shows how you can insert your own code\n  // just before every `ret` instruction across any code\n  // executed by the stalked thread inside the app's own\n  // memory range. It inserts code that checks if the `eax`\n  // register contains a value between 60 and 90, and inserts\n  // a synchronous callout back into JavaScript whenever that\n  // is the case. The callback receives a single argument\n  // that gives it access to the CPU registers, and it is\n  // also able to modify them.\n  //\n  // function onMatch (context) {\n  //   console.log('Match! pc=' + context.pc +\n  //       ' rax=' + context.rax.toInt32());\n  // }\n  //\n  // Note that not calling keep() will result in the\n  // instruction getting dropped, which makes it possible\n  // for your transform to fully replace certain instructions\n  // when this is desirable.\n  //\n\n  //\n  // Want better performance? Write the callbacks in C:\n  //\n  // /*\n  //  * const cm = new CModule(\\`\n  //  *\n  //  * #include <gum/gumstalker.h>\n  //  *\n  //  * static void on_ret (GumCpuContext * cpu_context,\n  //  *     gpointer user_data);\n  //  *\n  //  * void\n  //  * transform (GumStalkerIterator * iterator,\n  //  *            GumStalkerOutput * output,\n  //  *            gpointer user_data)\n  //  * {\n  //  *   cs_insn * insn;\n  //  *\n  //  *   while (gum_stalker_iterator_next (iterator, &insn))\n  //  *   {\n  //  *     if (insn->id == X86_INS_RET)\n  //  *     {\n  //  *       gum_x86_writer_put_nop (output->writer.x86);\n  //  *       gum_stalker_iterator_put_callout (iterator,\n  //  *           on_ret, NULL, NULL);\n  //  *     }\n  //  *\n  //  *     gum_stalker_iterator_keep (iterator);\n  //  *   }\n  //  * }\n  //  *\n  //  * static void\n  //  * on_ret (GumCpuContext * cpu_context,\n  //  *         gpointer user_data)\n  //  * {\n  //  *   printf (\"on_ret!\\n\");\n  //  * }\n  //  *\n  //  * void\n  //  * process (const GumEvent * event,\n  //  *          GumCpuContext * cpu_context,\n  //  *          gpointer user_data)\n  //  * {\n  //  *   switch (event->type)\n  //  *   {\n  //  *     case GUM_CALL:\n  //  *       break;\n  //  *     case GUM_RET:\n  //  *       break;\n  //  *     case GUM_EXEC:\n  //  *       break;\n  //  *     case GUM_BLOCK:\n  //  *       break;\n  //  *     case GUM_COMPILE:\n  //  *       break;\n  //  *     default:\n  //  *       break;\n  //  *   }\n  //  * }\n  //  * `);\n  //  */\n  //\n  //transform: cm.transform,\n  //onEvent: cm.process,\n  //data: ptr(1337) /* user_data */\n  //\n  // You may also use a hybrid approach and only write\n  // some of the callouts in C.\n  //\n});\n{% endhighlight %}\n\n<div class=\"note\">\n  <h5>Performance considerations</h5>\n  <p>\n    The callbacks provided have a significant impact on performance. If you only\n    need periodic call summaries but do not care about the raw events, or the\n    other way around, make sure you omit the callback that you don't need; i.e.\n    avoid putting your logic in <i>onCallSummary</i> and leaving\n    <i>onReceive</i> in there as an empty callback.\n  </p>\n  <p markdown=\"1\">\n    Also note that Stalker may be used in conjunction with **[CModule](#cmodule)**,\n    which means the callbacks may be implemented in C.\n  </p>\n</div>\n\n+   `Stalker.unfollow([threadId])`: stop stalking `threadId` (or the current\n    thread if omitted).\n    {: #stalker-unfollow}\n\n+   `Stalker.parse(events[, options])`: parse GumEvent binary blob, optionally\n    with `options` for customizing the output.\n\n    For example:\n\n{% highlight js %}\n  onReceive(events) {\n    console.log(Stalker.parse(events, {\n      annotate: true, // to display the type of event\n      stringify: true\n        // to format pointer values as strings instead of `NativePointer`\n        // values, i.e. less overhead if you're just going to `send()` the\n        // thing not actually parse the data agent-side\n    }));\n  },\n{% endhighlight %}\n\n+   `Stalker.flush()`: flush out any buffered events. Useful when you don't want\n    to wait until the next [`Stalker.queueDrainInterval`](#stalker-queuedraininterval) tick.\n    {: #stalker-flush}\n\n+   `Stalker.garbageCollect()`: free accumulated memory at a safe point after\n    [`Stalker#unfollow`](#stalker-unfollow). This is needed to avoid race-conditions\n    where the thread just unfollowed is executing its last instructions.\n\n+   `Stalker.invalidate(address)`: invalidates the current thread's translated\n    code for a given basic block. Useful when providing a transform callback and\n    wanting to dynamically adapt the instrumentation for a given basic block.\n    This is much more efficient than unfollowing and re-following the thread,\n    which would discard all cached translations and require all encountered\n    basic blocks to be compiled from scratch.\n\n+   `Stalker.invalidate(threadId, address)`: invalidates a specific thread's\n    translated code for a given basic block. Useful when providing a transform\n    callback and wanting to dynamically adapt the instrumentation for a given\n    basic block. This is much more efficient than unfollowing and re-following\n    the thread, which would discard all cached translations and require all\n    encountered basic blocks to be compiled from scratch.\n\n+   `Stalker.addCallProbe(address, callback[, data])`: call `callback` (see\n    [`Interceptor#attach#onEnter`](#interceptor-attach) for signature) synchronously\n    when a call is made to `address`. Returns an id that can be passed to\n    [`Stalker#removeCallProbe`](#stalker-removecallprobe) later.\n    {: #stalker-addcallprobe}\n\n    It is also possible to implement `callback` in C using **[CModule](#cmodule)**,\n    by specifying a [`NativePointer`](#nativepointer) instead of a function. Signature:\n\n    -   `void onCall (GumCallSite * site, gpointer user_data)`\n\n    In such cases, the third optional argument `data` may be a [`NativePointer`](#nativepointer)\n    whose value is passed to the callback as `user_data`.\n\n+   `Stalker.removeCallProbe`: remove a call probe added by\n    [`Stalker#addCallProbe`](#stalker-addcallprobe).\n    {: #stalker-removecallprobe}\n\n+   `Stalker.trustThreshold`: an integer specifying how many times a piece of\n    code needs to be executed before it is assumed it can be trusted to not\n    mutate.\n    Specify -1 for no trust (slow), 0 to trust code from the get-go, and N to\n    trust code after it has been executed N times. Defaults to 1.\n\n+   `Stalker.queueCapacity`: an integer specifying the capacity of the event\n    queue in number of events. Defaults to 16384 events.\n\n+   `Stalker.queueDrainInterval`: an integer specifying the time in milliseconds\n    between each time the event queue is drained. Defaults to 250 ms, which\n    means that the event queue is drained four times per second. You may also\n    set this property to zero to disable periodic draining, and instead call\n    [`Stalker.flush()`](#stalker-flush) when you would like the queue to be drained.\n    {: #stalker-queuedraininterval}\n\n\n### ObjC\n\n<div class=\"note\">\n<h5>Moved</h5>\n<p markdown=\"1\">\n    As of Frida 17, this runtime bridge is no longer baked into Frida's GumJS\n    runtime, and can be fetched by running: `npm install frida-objc-bridge`.\n    <br/>\n\n    Import it into your agent like this:<br/>\n    `import ObjC from 'frida-objc-bridge';`<br/>\n\n    For now this is not needed in scripts loaded by the Frida REPL, as well as\n    frida-trace.\n</p>\n</div>\n\n+   `ObjC.available`: a boolean specifying whether the current process has an\n    Objective-C runtime loaded. Do not invoke any other `ObjC` properties or\n    methods unless this is the case.\n    {: #objc-available}\n\n+   `ObjC.api`: an object mapping function names to [`NativeFunction`](#nativefunction) instances\n    for direct access to a big portion of the Objective-C runtime API.\n\n+   `ObjC.classes`: an object mapping class names to [`ObjC.Object`](#objc-object)\n    JavaScript bindings for each of the currently registered classes. You can interact\n    with objects by using dot notation and replacing colons with underscores, i.e.:\n    `[NSString stringWithString:@\"Hello World\"]`\n    becomes\n    `const { NSString } = ObjC.classes; NSString.stringWithString_(\"Hello World\");`.\n    Note the underscore after the method name. Refer to iOS Examples section for\n    more details.\n    {: #objc-classes}\n\n+   `ObjC.protocols`: an object mapping protocol names to [`ObjC.Protocol`](#objc-protocol)\n    JavaScript bindings for each of the currently registered protocols.\n\n+   `ObjC.mainQueue`: the GCD queue of the main thread\n\n+   `ObjC.schedule(queue, work)`: schedule the JavaScript function `work` on\n    the GCD queue specified by `queue`. An `NSAutoreleasePool` is created just\n    before calling `work`, and cleaned up on return.\n\n{% highlight js %}\nconst { NSSound } = ObjC.classes; /* macOS */\nObjC.schedule(ObjC.mainQueue, () => {\n    const sound = NSSound.alloc().initWithContentsOfFile_byReference_(\"/Users/oleavr/.Trash/test.mp3\", true);\n    sound.play();\n});\n{% endhighlight %}\n\n+   <code id=\"objc-object\">new ObjC.Object(handle[, protocol])</code>: create a JavaScript binding given\n    the existing object at `handle` (a **[NativePointer](#nativepointer)**). You may\n    also specify the `protocol` argument if you'd like to treat `handle` as an object\n    implementing a certain protocol only.\n\n{% highlight js %}\nInterceptor.attach(myFunction.implementation, {\n  onEnter(args) {\n    // ObjC: args[0] = self, args[1] = selector, args[2-n] = arguments\n    const myString = new ObjC.Object(args[2]);\n    console.log(\"String argument: \" + myString.toString());\n  }\n});\n{% endhighlight %}\n\n>   This object has some special properties:\n>\n>   -   `$kind`: string specifying either `instance`, `class` or `meta-class`\n>   -   `$super`: an **[ObjC.Object](#objc-object)** instance used for chaining up to\n>       super-class method implementations\n>   -   `$superClass`: super-class as an **[ObjC.Object](#objc-object)** instance\n>   -   `$class`: class of this object as an **[ObjC.Object](#objc-object)** instance\n>   -   `$className`: string containing the class name of this object\n>   -   `$moduleName`: string containing the module path of this object\n>   -   `$protocols`: object mapping protocol name to [`ObjC.Protocol`](#objc-protocol)\n>       instance for each of the protocols that this object conforms to\n>   -   `$methods`: array containing native method names exposed by this object's\n>       class and parent classes\n>   -   `$ownMethods`: array containing native method names exposed by this object's\n>       class, not including parent classes\n>   -   `$ivars`: object mapping each instance variable name to its current\n>       value, allowing you to read and write each through access and assignment\n>\n>   There is also an `equals(other)` method for checking whether two instances\n>   refer to the same underlying object.\n>\n>   Note that all method wrappers provide a `clone(options)` API to create a new\n>   method wrapper with custom **[NativeFunction](#nativefunction)** options.\n\n+   `new ObjC.Protocol(handle)`: create a JavaScript binding given the existing\n    protocol at `handle` (a **[NativePointer](#nativepointer)**).\n    {: #objc-protocol}\n\n+   `new ObjC.Block(target[, options])`: create a JavaScript binding given the\n    existing block at `target` (a **[NativePointer](#nativepointer)**), or, to define\n    a new block, `target` should be an object specifying the type signature and\n    JavaScript function to call whenever the block is invoked. The function is\n    specified with an `implementation` key, and the signature is specified either\n    through a `types` key, or through the `retType` and `argTypes` keys. See\n    [`ObjC.registerClass()`](#objc-registerclass) for details.\n\n    Note that if an existing block lacks signature metadata, you may call\n    `declare(signature)`, where `signature` is an object with either a `types`\n    key, or `retType` and `argTypes` keys, as described above.\n\n    You may also provide an `options` object with the same options as supported\n    by **[NativeFunction](#nativefunction)**, e.g. to pass `traps: 'all'` in order\n    to [`Stalker.follow()`](#stalker-follow) the execution when calling the block.\n\n    The most common use-case is hooking an existing block, which for a block\n    expecting two arguments would look something like:\n\n{% highlight js %}\nconst pendingBlocks = new Set();\n\nInterceptor.attach(..., {\n  onEnter(args) {\n    const block = new ObjC.Block(args[4]);\n    pendingBlocks.add(block); // Keep it alive\n    const appCallback = block.implementation;\n    block.implementation = (error, value) => {\n      // Do your logging here\n      const result = appCallback(error, value);\n      pendingBlocks.delete(block);\n      return result;\n    };\n  }\n});\n{% endhighlight %}\n\n+   `ObjC.implement(method, fn)`: create a JavaScript implementation compatible\n    with the signature of `method`, where the JavaScript function `fn` is used\n    as the implementation. Returns a [`NativeCallback`](#nativecallback) that you may\n    assign to an ObjC method's `implementation` property.\n\n{% highlight js %}\nconst NSSound = ObjC.classes.NSSound; /* macOS */\nconst oldImpl = NSSound.play.implementation;\nNSSound.play.implementation = ObjC.implement(NSSound.play, (handle, selector) => {\n  return oldImpl(handle, selector);\n});\n\nconst NSView = ObjC.classes.NSView; /* macOS */\nconst drawRect = NSView['- drawRect:'];\nconst oldImpl = drawRect.implementation;\ndrawRect.implementation = ObjC.implement(drawRect, (handle, selector) => {\n  oldImpl(handle, selector);\n});\n{% endhighlight %}\n\n>   As the `implementation` property is a [`NativeFunction`](#nativefunction) and thus also a\n>   [`NativePointer`](#nativepointer), you may also use [`Interceptor`](#interceptor) to hook functions:\n\n{% highlight js %}\nconst { NSSound } = ObjC.classes; /* macOS */\nInterceptor.attach(NSSound.play.implementation, {\n  onEnter() {\n    send(\"[NSSound play]\");\n  }\n});\n{% endhighlight %}\n\n+   `ObjC.registerProxy(properties)`: create a new class designed to act as a\n    proxy for a target object, where `properties` is an object specifying:\n\n    -   `protocols`: (optional) Array of protocols this class conforms to.\n    -   `methods`: (optional) Object specifying methods to implement.\n    -   `events`: (optional) Object specifying callbacks for getting notified\n        about events:\n        -   `dealloc()`: Called right after the object has been deallocated.\n            This is where you might clean up any associated state.\n        -   `forward(name)`: Called with `name` specifying the method name that\n            we're about to forward a call to. This might be where you'd start\n            out with a temporary callback that just logs the names to help you\n            decide which methods to override.\n\n{% highlight js %}\nconst MyConnectionDelegateProxy = ObjC.registerProxy({\n  protocols: [ObjC.protocols.NSURLConnectionDataDelegate],\n  methods: {\n    '- connection:didReceiveResponse:': function (conn, resp) {\n      /* fancy logging code here */\n      /* this.data.foo === 1234 */\n      this.data.target\n          .connection_didReceiveResponse_(conn, resp);\n    },\n    '- connection:didReceiveData:': function (conn, data) {\n      /* other logging code here */\n      this.data.target\n          .connection_didReceiveData_(conn, data);\n    }\n  },\n  events: {\n    forward(name) {\n      console.log('*** forwarding: ' + name);\n    }\n  }\n});\n\nconst method = ObjC.classes.NSURLConnection[\n    '- initWithRequest:delegate:startImmediately:'];\nInterceptor.attach(method.implementation, {\n  onEnter(args) {\n    args[3] = new MyConnectionDelegateProxy(args[3], {\n      foo: 1234\n    });\n  }\n});\n{% endhighlight %}\n\n+   `ObjC.registerClass(properties)`: create a new Objective-C class, where\n    `properties` is an object specifying:\n    {: #objc-registerclass}\n\n    -   `name`: (optional) String specifying the name of the class; omit this\n        if you don't care about the globally visible name and would like the\n        runtime to auto-generate one for you.\n    -   `super`: (optional) Super-class, or *null* to create a new root class;\n        omit to inherit from *NSObject*.\n    -   `protocols`: (optional) Array of protocols this class conforms to.\n    -   `methods`: (optional) Object specifying methods to implement.\n\n{% highlight js %}\nconst MyConnectionDelegateProxy = ObjC.registerClass({\n  name: 'MyConnectionDelegateProxy',\n  super: ObjC.classes.NSObject,\n  protocols: [ObjC.protocols.NSURLConnectionDataDelegate],\n  methods: {\n    '- init': function () {\n      const self = this.super.init();\n      if (self !== null) {\n        ObjC.bind(self, {\n          foo: 1234\n        });\n      }\n      return self;\n    },\n    '- dealloc': function () {\n      ObjC.unbind(this.self);\n      this.super.dealloc();\n    },\n    '- connection:didReceiveResponse:': function (conn, resp) {\n      /* this.data.foo === 1234 */\n    },\n    /*\n     * But those previous methods are declared assuming that\n     * either the super-class or a protocol we conform to has\n     * the same method so we can grab its type information.\n     * However, if that's not the case, you would write it\n     * like this:\n     */\n    '- connection:didReceiveResponse:': {\n      retType: 'void',\n      argTypes: ['object', 'object'],\n      implementation(conn, resp) {\n      }\n    },\n    /* Or grab it from an existing class: */\n    '- connection:didReceiveResponse:': {\n      types: ObjC.classes\n          .Foo['- connection:didReceiveResponse:'].types,\n      implementation(conn, resp) {\n      }\n    },\n    /* Or from an existing protocol: */\n    '- connection:didReceiveResponse:': {\n      types: ObjC.protocols.NSURLConnectionDataDelegate\n          .methods['- connection:didReceiveResponse:'].types,\n      implementation(conn, resp) {\n      }\n    },\n    /* Or write the signature by hand if you really want to: */\n    '- connection:didReceiveResponse:': {\n      types: 'v32@0:8@16@24',\n      implementation(conn, resp) {\n      }\n    }\n  }\n});\n\nconst proxy = MyConnectionDelegateProxy.alloc().init();\n/* use `proxy`, and later: */\nproxy.release();\n{% endhighlight %}\n\n+   `ObjC.registerProtocol(properties)`: create a new Objective-C protocol,\n    where `properties` is an object specifying:\n\n    -   `name`: (optional) String specifying the name of the protocol; omit this\n        if you don't care about the globally visible name and would like the\n        runtime to auto-generate one for you.\n    -   `protocols`: (optional) Array of protocols this protocol incorporates.\n    -   `methods`: (optional) Object specifying methods to declare.\n\n{% highlight js %}\nconst MyDataDelegate = ObjC.registerProtocol({\n  name: 'MyDataDelegate',\n  protocols: [ObjC.protocols.NSURLConnectionDataDelegate],\n  methods: {\n    /* You must specify the signature: */\n    '- connection:didStuff:': {\n      retType: 'void',\n      argTypes: ['object', 'object']\n    },\n    /* Or grab it from a method of an existing class: */\n    '- connection:didStuff:': {\n      types: ObjC.classes\n          .Foo['- connection:didReceiveResponse:'].types\n    },\n    /* Or from an existing protocol method: */\n    '- connection:didStuff:': {\n      types: ObjC.protocols.NSURLConnectionDataDelegate\n          .methods['- connection:didReceiveResponse:'].types\n    },\n    /* Or write the signature by hand if you really want to: */\n    '- connection:didStuff:': {\n      types: 'v32@0:8@16@24'\n    },\n    /* You can also make a method optional (default is required): */\n    '- connection:didStuff:': {\n      retType: 'void',\n      argTypes: ['object', 'object'],\n      optional: true\n    }\n  }\n});\n{% endhighlight %}\n\n+   `ObjC.bind(obj, data)`: bind some JavaScript data to an Objective-C\n    instance; see [`ObjC.registerClass()`](#objc-registerclass) for an example.\n\n+   `ObjC.unbind(obj)`: unbind previous associated JavaScript data from an\n    Objective-C instance; see [`ObjC.registerClass()`](#objc-registerclass) for an example.\n\n+   `ObjC.getBoundData(obj)`: look up previously bound data from an Objective-C\n    object.\n\n+   `ObjC.enumerateLoadedClasses([options, ]callbacks)`: enumerate classes\n    loaded right now, where `callbacks` is an object specifying:\n    {: #objc-enumerateloadedclasses}\n\n    -   `onMatch(name, owner)`: called for each loaded class with the `name` of\n        the class as a string, and `owner` specifying the path to the module\n        where the class was loaded from. To obtain a JavaScript wrapper for a\n        given class, do: [`ObjC.classes[name]`](#objc-classes).\n\n    -   `onComplete()`: called when all classes have been enumerated.\n\n    For example:\n\n{% highlight js %}\nObjC.enumerateLoadedClasses({\n  onMatch(name, owner) {\n    console.log('onMatch:', name, owner);\n  },\n  onComplete() {\n  }\n});\n{% endhighlight %}\n\nThe optional `options` argument is an object where you may specify the\n`ownedBy` property to limit enumeration to modules in a given [`ModuleMap`](#modulemap).\n\nFor example:\n\n{% highlight js %}\nconst appModules = new ModuleMap(isAppModule);\nObjC.enumerateLoadedClasses({ ownedBy: appModules }, {\n  onMatch(name, owner) {\n    console.log('onMatch:', name, owner);\n  },\n  onComplete() {\n  }\n});\n\nfunction isAppModule(m) {\n  return !/^\\/(usr\\/lib|System|Developer)\\//.test(m.path);\n}\n{% endhighlight %}\n\n+   `ObjC.enumerateLoadedClassesSync([options])`: synchronous version of\n    [`enumerateLoadedClasses()`](#objc-enumerateloadedclasses) that returns an object\n    mapping owner module to an array of class names.\n\n    For example:\n\n{% highlight js %}\nconst appModules = new ModuleMap(isAppModule);\nconst appClasses = ObjC.enumerateLoadedClassesSync({ ownedBy: appModules });\nconsole.log('appClasses:', JSON.stringify(appClasses));\n\nfunction isAppModule(m) {\n  return !/^\\/(usr\\/lib|System|Developer)\\//.test(m.path);\n}\n{% endhighlight %}\n\n+   `ObjC.choose(specifier, callbacks)`: enumerate live instances of classes\n    matching `specifier` by scanning the heap. `specifier` is either a class\n    selector or an object specifying a class selector and desired options.\n    The class selector is an **[ObjC.Object](#objc-object)** of a class, e.g.\n    *ObjC.classes.UIButton*.\n    When passing an object as the specifier you should provide the `class`\n    field with your class selector, and the `subclasses` field with a\n    boolean indicating whether you're also interested in subclasses matching the\n    given class selector. The default is to also include subclasses.\n    The `callbacks` argument is an object specifying:\n    {: #objc-choose}\n\n    -   `onMatch(instance)`: called once for each live instance found with a\n        ready-to-use `instance` just as if you would have called\n        [`new ObjC.Object(ptr(\"0x1234\"))`](#objc-object) knowing that this\n        particular Objective-C instance lives at *0x1234*.\n\n        This function may return the string `stop` to cancel the enumeration\n        early.\n\n    -   `onComplete()`: called when all instances have been enumerated\n\n+   `ObjC.chooseSync(specifier)`: synchronous version of [`choose()`](#objc-choose)\n    that returns the instances in an array.\n\n+   `ObjC.selector(name)`: convert the JavaScript string `name` to a selector\n\n+   `ObjC.selectorAsString(sel)`: convert the selector `sel` to a JavaScript\n    string\n\n\n### Java\n\n<div class=\"note\">\n<h5>Moved</h5>\n<p markdown=\"1\">\n    As of Frida 17, this runtime bridge is no longer baked into Frida's GumJS\n    runtime, and can be fetched by running: `npm install frida-java-bridge`.\n    <br/>\n\n    Import it into your agent like this:<br/>\n    `import Java from 'frida-java-bridge';`<br/>\n\n    For now this is not needed in scripts loaded by the Frida REPL, as well as\n    frida-trace.\n</p>\n</div>\n\n+   `Java.available`: a boolean specifying whether the current process has the\n    a Java VM loaded, i.e. Dalvik or ART. Do not invoke any other `Java`\n    properties or methods unless this is the case.\n\n+   `Java.androidVersion`: a string specifying which version of Android we're\n    running on.\n\n+   `ACC_PUBLIC`,\n    `ACC_PRIVATE`,\n    `ACC_PROTECTED`,\n    `ACC_STATIC`,\n    `ACC_FINAL`,\n    `ACC_SYNCHRONIZED`,\n    `ACC_BRIDGE`,\n    `ACC_VARARGS`,\n    `ACC_NATIVE`,\n    `ACC_ABSTRACT`,\n    `ACC_STRICT`,\n    `ACC_SYNTHETIC`: method flag constants, each a number, to be used with e.g.\n    [`Java.backtrace()`](#java-backtrace).\n\n+   `Java.enumerateLoadedClasses(callbacks)`: enumerate classes loaded right\n    now, where `callbacks` is an object specifying:\n    {: #java-enumerateloadedclasses}\n\n    -   `onMatch(name, handle)`: called for each loaded class with `name` that\n        may be passed to [`use()`](#java-use) to get a JavaScript wrapper.\n        You may also [`Java.cast()`](#java-cast) the `handle` to `java.lang.Class`.\n\n    -   `onComplete()`: called when all classes have been enumerated.\n\n+   `Java.enumerateLoadedClassesSync()`: synchronous version of\n    [`enumerateLoadedClasses()`](#java-enumerateloadedclasses) that returns the\n    class names in an array.\n\n+   `Java.enumerateClassLoaders(callbacks)`: enumerate class loaders present\n    in the Java VM, where `callbacks` is an object specifying:\n    {: #java-enumerateclassloaders}\n\n    -   `onMatch(loader)`: called for each class loader with `loader`, a wrapper\n        for the specific `java.lang.ClassLoader`.\n\n    -   `onComplete()`: called when all class loaders have been enumerated.\n\n    You may pass such a loader to `Java.ClassFactory.get()` to be able to\n    [`.use()`](#java-use) classes on the specified class loader.\n\n+   `Java.enumerateClassLoadersSync()`: synchronous version of\n    [`enumerateClassLoaders()`](#java-enumerateclassloaders) that returns the\n    class loaders in an array.\n\n+   `Java.enumerateMethods(query)`: enumerate methods matching `query`,\n    specified as `\"class!method\"`, with globs permitted. May also be suffixed\n    with `/` and one or more modifiers:\n\n    -   `i`: Case-insensitive matching.\n    -   `s`: Include method signatures, so e.g. `\"putInt\"` becomes\n        `\"putInt(java.lang.String, int): void\"`.\n    -   `u`: User-defined classes only, ignoring system classes.\n\n{% highlight js %}\nJava.perform(() => {\n  const groups = Java.enumerateMethods('*youtube*!on*')\n  console.log(JSON.stringify(groups, null, 2));\n});\n{% endhighlight %}\n\n{% highlight json %}\n[\n  {\n    \"loader\": \"<instance: java.lang.ClassLoader, $className: dalvik.system.PathClassLoader>\",\n    \"classes\": [\n      {\n        \"name\": \"com.google.android.apps.youtube.app.watch.nextgenwatch.ui.NextGenWatchLayout\",\n        \"methods\": [\n          \"onAttachedToWindow\",\n          \"onDetachedFromWindow\",\n          \"onFinishInflate\",\n          \"onInterceptTouchEvent\",\n          \"onLayout\",\n          \"onMeasure\",\n          \"onSizeChanged\",\n          \"onTouchEvent\",\n          \"onViewRemoved\"\n        ]\n      },\n      {\n        \"name\": \"com.google.android.apps.youtube.app.search.suggest.YouTubeSuggestionProvider\",\n        \"methods\": [\n          \"onCreate\"\n        ]\n      },\n      {\n        \"name\": \"com.google.android.libraries.youtube.common.ui.YouTubeButton\",\n        \"methods\": [\n          \"onInitializeAccessibilityNodeInfo\"\n        ]\n      },\n      …\n    ]\n  }\n]\n{% endhighlight %}\n\n+   `Java.scheduleOnMainThread(fn)`: run `fn` on the main thread of the VM.\n\n+   `Java.perform(fn)`: ensure that the current thread is attached to the VM\n    and call `fn`. (This isn't necessary in callbacks from Java.)\n    Will defer calling `fn` if the app's class loader is not available yet.\n    Use [`Java.performNow()`](#java-performnow) if access to the app's classes is not needed.\n    {: #java-perform}\n\n{% highlight js %}\nJava.perform(() => {\n  const Activity = Java.use('android.app.Activity');\n  Activity.onResume.implementation = function () {\n    send('onResume() got called! Let\\'s call the original implementation');\n    this.onResume();\n  };\n});\n{% endhighlight %}\n\n+   `Java.performNow(fn)`: ensure that the current thread is attached to the\n    VM and call `fn`. (This isn't necessary in callbacks from Java.)\n    {: #java-performnow}\n\n+   `Java.use(className)`: dynamically get a JavaScript wrapper for\n    `className` that you can instantiate objects from by calling `$new()` on\n    it to invoke a constructor. Call `$dispose()` on an instance to clean it\n    up explicitly (or wait for the JavaScript object to get garbage-collected,\n    or script to get unloaded). Static and non-static methods are available,\n    and you can even replace a method implementation and throw an exception\n    from it:\n    {: #java-use}\n\n{% highlight js %}\nJava.perform(() => {\n  const Activity = Java.use('android.app.Activity');\n  const Exception = Java.use('java.lang.Exception');\n  Activity.onResume.implementation = function () {\n    throw Exception.$new('Oh noes!');\n  };\n});\n{% endhighlight %}\n\n>   Uses the app's class loader by default, but you may customize this by\n>   assigning a different loader instance to `Java.classFactory.loader`.\n>\n>   Note that all method wrappers provide a `clone(options)` API to create a new\n>   method wrapper with custom **[NativeFunction](#nativefunction)** options.\n\n+   `Java.openClassFile(filePath)`: open the .dex file at `filePath`, returning\n    an object with the following methods:\n    {: #java-openclassfile}\n\n    -   `load()`: load the contained classes into the VM.\n\n    -   `getClassNames()`: obtain an array of available class names.\n\n+   `Java.choose(className, callbacks)`: enumerate live instances of the\n    `className` class by scanning the Java heap, where `callbacks` is an\n    object specifying:\n    {: #java-choose}\n\n    -   `onMatch(instance)`: called with each live instance found with a\n        ready-to-use `instance` just as if you would have called\n        [`Java.cast()`](#java-cast) with a raw handle to this particular instance.\n\n        This function may return the string `stop` to cancel the enumeration\n        early.\n\n    -   `onComplete()`: called when all instances have been enumerated\n\n+   `Java.retain(obj)`: duplicates the JavaScript wrapper `obj` for later use\n    outside replacement method.\n    {: #java-retain}\n\n{% highlight js %}\nJava.perform(() => {\n  const Activity = Java.use('android.app.Activity');\n  let lastActivity = null;\n  Activity.onResume.implementation = function () {\n    lastActivity = Java.retain(this);\n    this.onResume();\n  };\n});\n{% endhighlight %}\n\n+   <code id=\"java-cast\">Java.cast(handle, klass)</code>: create a JavaScript wrapper\n    given the existing instance at `handle` of given class `klass` as returned from\n    [`Java.use()`](#java-use).\n    Such a wrapper also has a `class` property for getting a wrapper for its\n    class, and a `$className` property for getting a string representation of\n    its class-name.\n\n{% highlight js %}\nconst Activity = Java.use('android.app.Activity');\nconst activity = Java.cast(ptr('0x1234'), Activity);\n{% endhighlight %}\n\n+   <code id=\"java-array\">Java.array(type, elements)</code>: creates a Java array with\n     elements of the specified `type`, from a JavaScript array `elements`. The\n     resulting Java array behaves like a JS array, but can be passed by reference to\n     Java APIs in order to allow them to modify its contents.\n\n{% highlight js %}\nconst values = Java.array('int', [ 1003, 1005, 1007 ]);\n\nconst JString = Java.use('java.lang.String');\nconst str = JString.$new(Java.array('byte', [ 0x48, 0x65, 0x69 ]));\n{% endhighlight %}\n\n+   `Java.backtrace([options])`: generates a backtrace for the current thread.\n    {: #java-backtrace}\n\n    The optional `options` argument is an object that may contain some of the\n    following keys:\n\n    -   `limit`: how many frames up the stack to walk, as a number.\n        Defaults to 16.\n\n    Returns an object with the following properties:\n\n    -   `id`: ID that can be used for deduplicating identical backtraces, as a\n        string.\n    -   `frames`: stack frames. An array of objects containing the following\n        properties:\n\n        -   `signature`: stack frame signature as a string, e.g.\n            `Landroid/os/Looper;,loopOnce,(Landroid/os/Looper;JI)Z`\n        -   `origin`: where the code is from, i.e. a string specifying a\n            filesystem path. On Android this is the path to the `.dex`.\n        -   `className`: class name that method belongs to, as a string, e.g.\n            `android.os.Looper`\n        -   `methodName`: method name as a string, e.g. `loopOnce`\n        -   `methodFlags`: method flags as a number, e.g.\n            `Java.ACC_PUBLIC | Java.ACC_STATIC`\n        -   `fileName`: source file name as a string, e.g. `Looper.java`\n        -   `lineNumber`: source line number as a number, e.g. `201`\n\n+   `Java.isMainThread()`: determine whether the caller is running on the main\n    thread.\n\n+   `Java.registerClass(spec)`: create a new Java class and return a wrapper for\n    it, where `spec` is an object containing:\n    {: #java-registerclass}\n\n    -   `name`: String specifying the name of the class.\n    -   `superClass`: (optional) Super-class. Omit to inherit from\n                      `java.lang.Object`.\n    -   `implements`: (optional) Array of interfaces implemented by this class.\n    -   `fields`: (optional) Object specifying the name and type of each field\n                  to expose.\n    -   `methods`: (optional) Object specifying methods to implement.\n\n{% highlight js %}\nconst SomeBaseClass = Java.use('com.example.SomeBaseClass');\nconst X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');\n\nconst MyTrustManager = Java.registerClass({\n  name: 'com.example.MyTrustManager',\n  implements: [X509TrustManager],\n  methods: {\n    checkClientTrusted(chain, authType) {\n    },\n    checkServerTrusted(chain, authType) {\n    },\n    getAcceptedIssuers() {\n      return [];\n    },\n  }\n});\n\nconst MyWeirdTrustManager = Java.registerClass({\n  name: 'com.example.MyWeirdTrustManager',\n  superClass: SomeBaseClass,\n  implements: [X509TrustManager],\n  fields: {\n    description: 'java.lang.String',\n    limit: 'int',\n  },\n  methods: {\n    $init() {\n      console.log('Constructor called');\n    },\n    checkClientTrusted(chain, authType) {\n      console.log('checkClientTrusted');\n    },\n    checkServerTrusted: [{\n      returnType: 'void',\n      argumentTypes: ['[Ljava.security.cert.X509Certificate;', 'java.lang.String'],\n      implementation(chain, authType) {\n        console.log('checkServerTrusted A');\n      }\n    }, {\n      returnType: 'java.util.List',\n      argumentTypes: ['[Ljava.security.cert.X509Certificate;', 'java.lang.String', 'java.lang.String'],\n      implementation(chain, authType, host) {\n        console.log('checkServerTrusted B');\n        return null;\n      }\n    }],\n    getAcceptedIssuers() {\n      console.log('getAcceptedIssuers');\n      return [];\n    },\n  }\n});\n{% endhighlight %}\n\n+   `Java.deoptimizeEverything()`: forces the VM to execute everything with\n    its interpreter. Necessary to prevent optimizations from bypassing method\n    hooks in some cases, and allows ART's Instrumentation APIs to be used for\n    tracing the runtime.\n\n+   `Java.deoptimizeBootImage()`: similar to Java.deoptimizeEverything() but\n     only deoptimizes boot image code. Use with\n     `dalvik.vm.dex2oat-flags --inline-max-code-units=0` for best results.\n\n+   `Java.vm`: object with the following methods:\n\n    -   `perform(fn)`: ensures that the current thread is attached to the VM and\n        calls `fn`. (This isn't necessary in callbacks from Java.)\n\n    -   `getEnv()`: gets a wrapper for the current thread's `JNIEnv`. Throws an\n        exception if the current thread is not attached to the VM.\n\n    -   `tryGetEnv()`: tries to get a wrapper for the current thread's `JNIEnv`.\n        Returns `null` if the current thread is not attached to the VM.\n\n+   `Java.classFactory`: the default class factory used to implement e.g.\n    [`Java.use()`](#java-use). Uses the application's main class loader.\n\n+   `Java.ClassFactory`: class with the following properties:\n\n    +   `get(classLoader)`: Gets the class factory instance for a given class\n        loader. The default class factory used behind the scenes only interacts\n        with the application's main class loader. Other class loaders can be\n        discovered through `Java.enumerateClassLoaders()` and interacted with\n        through this API.\n\n    -   `loader`: read-only property providing a wrapper for the class loader\n        currently being used. For the default class factory this is updated by\n        the first call to [`Java.perform()`](#java-perform).\n\n    -   `cacheDir`: string containing path to cache directory currently being\n        used. For the default class factory this is updated by the first call\n        to [`Java.perform()`](#java-perform).\n\n    -   `tempFileNaming`: object specifying naming convention to use for\n        temporary files. Defaults to `{ prefix: 'frida', suffix: 'dat' }`.\n\n    -   `use(className)`: like [`Java.use()`](#java-use) but for a specific class loader.\n\n    -   `openClassFile(filePath)`: like [`Java.openClassFile()`](#java-openclassfile)\n        but for a specific class loader.\n\n    -   `choose(className, callbacks)`: like [`Java.choose()`](#java-choose) but for a\n        specific class loader.\n\n    -   `retain(obj)`: like [`Java.retain()`](#java-retain) but for a specific class loader.\n\n    -   `cast(handle, klass)`: like [`Java.cast()`](#java-cast) but for a specific class\n        loader.\n\n    -   `array(type, elements)`: like [`Java.array()`](#java-array) but for a specific class\n        loader.\n\n    -   `registerClass(spec)`: like [`Java.registerClass()`](#java-registerclass) but for a specific\n         class loader.\n\n---",
      "keywords": [
        "Interceptor.attach",
        "API",
        "getExportByName",
        "onEnter",
        "onLeave",
        "retval.replace",
        "ptr",
        "retval.toString",
        "gum_invocation_context_get_listener_function_data",
        "detach",
        "invocation",
        "Process.getModuleByName",
        "libc.getExportByName",
        "toInt32",
        "if",
        "retval.toInt32",
        "value",
        "Module.getGlobalExportByName",
        "console.log",
        "JSON.stringify",
        "1",
        "result.toInt32",
        "hexdump",
        "send",
        "Interceptor.detachAll",
        "Interceptor.replace",
        "gum_interceptor_get_current_invocation",
        "NativeFunction",
        "NativeCallback",
        "pathPtr.readUtf8String",
        "log",
        "open",
        "Interceptor.replaceFast",
        "replace",
        "Interceptor.revert",
        "Interceptor.flush",
        "attach",
        "Stalker.exclude",
        "Stalker.follow",
        "Process.enumerateThreads",
        "Stalker.parse",
        "onReceive",
        "onCallSummary",
        "transform",
        "iterator.next",
        "startAddress.compare",
        "iterator.putCmpRegI32",
        "iterator.putJccShortLabel",
        "iterator.putCallout",
        "iterator.putLabel"
      ],
      "examples": []
    },
    {
      "id": "cpu-instruction",
      "title": "CPU Instruction",
      "category": "Other",
      "content": "## CPU Instruction\n\n### Instruction\n\n+   `Instruction.parse(target)`: parse the instruction at the `target` address\n    in memory, represented by a [`NativePointer`](#nativepointer).\n    Note that on 32-bit ARM this address must have its least significant bit\n    set to 0 for ARM functions, and 1 for Thumb functions. Frida takes care\n    of this detail for you if you get the address from a Frida API (for\n    example [`Module#getExportByName()`](#module-getexportbyname)).\n\n    The object returned has the fields:\n\n    -   `address`: address (EIP) of this instruction, as a [`NativePointer`](#nativepointer)\n    -   `next`: pointer to the next instruction, so you can `parse()` it\n    -   `size`: size of this instruction\n    -   `mnemonic`: string representation of instruction mnemonic\n    -   `opStr`: string representation of instruction operands\n    -   `operands`: array of objects describing each operand, each specifying\n                    the `type` and `value`, at a minimum, but potentially also\n                    additional properties depending on the architecture\n    -   `regsRead`: array of register names implicitly read by this instruction\n    -   `regsWritten`: array of register names implicitly written to by this\n        instruction\n    -   `groups`: array of group names that this instruction belongs to\n    -   `toString()`: convert to a human-readable string\n\n    For details about `operands` and `groups`, please consult the\n    **[Capstone](http://www.capstone-engine.org/)** documentation for your\n    architecture.\n\n\n### X86Writer\n\n+   `new X86Writer(codeAddress[, { pc: ptr('0x1234') }])`: create a new code\n    writer for generating x86 machine code written directly to memory at\n    `codeAddress`, specified as a **[NativePointer](#nativepointer)**.\n    The second argument is an optional options object where the initial program\n    counter may be specified, which is useful when generating code to a scratch\n    buffer. This is essential when using [`Memory.patchCode()`](#memory-patchcode)\n    on iOS, which may provide you with a temporary location that later gets mapped\n    into memory at the intended memory location.\n\n-   `reset(codeAddress[, { pc: ptr('0x1234') }])`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `flush()`: resolve label references and write pending data to memory. You\n    should always call this once you've finished generating code. It is usually\n    also desirable to do this between pieces of unrelated code, e.g. when\n    generating multiple functions in one go.\n\n-   `base`: memory location of the first byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `code`: memory location of the next byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `pc`: program counter at the next byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `offset`: current offset as a JavaScript Number\n\n-   `putLabel(id)`: put a label at the current position, where `id` is a string\n    that may be referenced in past and future `put*Label()` calls\n    {: #x86writer-putlabel}\n\n-   `putCallAddressWithArguments(func, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putCallAddressWithAlignedArguments(func, args)`: like above, but also\n    ensures that the argument list is aligned on a 16 byte boundary\n\n-   `putCallRegWithArguments(reg, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putCallRegWithAlignedArguments(reg, args)`: like above, but also\n    ensures that the argument list is aligned on a 16 byte boundary\n\n-   `putCallRegOffsetPtrWithArguments(reg, offset, args)`: put code needed for calling\n    a C function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putCallAddress(address)`: put a CALL instruction\n\n-   `putCallReg(reg)`: put a CALL instruction\n\n-   `putCallRegOffsetPtr(reg, offset)`: put a CALL instruction\n\n-   `putCallIndirect(addr)`: put a CALL instruction\n\n-   `putCallIndirectLabel(labelId)`: put a CALL instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#x86writer-putlabel)\n\n-   `putCallNearLabel(labelId)`: put a CALL instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#x86writer-putlabel)\n\n-   `putLeave()`: put a LEAVE instruction\n\n-   `putRet()`: put a RET instruction\n\n-   `putRetImm(immValue)`: put a RET instruction\n\n-   `putJmpAddress(address)`: put a JMP instruction\n\n-   `putJmpShortLabel(labelId)`: put a JMP instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#x86writer-putlabel)\n\n-   `putJmpNearLabel(labelId)`: put a JMP instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#x86writer-putlabel)\n\n-   `putJmpReg(reg)`: put a JMP instruction\n\n-   `putJmpRegPtr(reg)`: put a JMP instruction\n\n-   `putJmpRegOffsetPtr(reg, offset)`: put a JMP instruction\n\n-   `putJmpNearPtr(address)`: put a JMP instruction\n\n-   `putJccShort(instructionId, target, hint)`: put a JCC instruction\n\n-   `putJccNear(instructionId, target, hint)`: put a JCC instruction\n\n-   `putJccShortLabel(instructionId, labelId, hint)`: put a JCC instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#x86writer-putlabel)\n\n-   `putJccNearLabel(instructionId, labelId, hint)`: put a JCC instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#x86writer-putlabel)\n\n-   `putAddRegImm(reg, immValue)`: put an ADD instruction\n\n-   `putAddRegReg(dstReg, srcReg)`: put an ADD instruction\n\n-   `putAddRegNearPtr(dstReg, srcAddress)`: put an ADD instruction\n\n-   `putSubRegImm(reg, immValue)`: put a SUB instruction\n\n-   `putSubRegReg(dstReg, srcReg)`: put a SUB instruction\n\n-   `putSubRegNearPtr(dstReg, srcAddress)`: put a SUB instruction\n\n-   `putIncReg(reg)`: put an INC instruction\n\n-   `putDecReg(reg)`: put a DEC instruction\n\n-   `putIncRegPtr(target, reg)`: put an INC instruction\n\n-   `putDecRegPtr(target, reg)`: put a DEC instruction\n\n-   `putLockXaddRegPtrReg(dstReg, srcReg)`: put a LOCK XADD instruction\n\n-   `putLockCmpxchgRegPtrReg(dstReg, srcReg)`: put a LOCK CMPXCHG instruction\n\n-   `putLockIncImm32Ptr(target)`: put a LOCK INC IMM32 instruction\n\n-   `putLockDecImm32Ptr(target)`: put a LOCK DEC IMM32 instruction\n\n-   `putAndRegReg(dstReg, srcReg)`: put an AND instruction\n\n-   `putAndRegU32(reg, immValue)`: put an AND instruction\n\n-   `putShlRegU8(reg, immValue)`: put a SHL instruction\n\n-   `putShrRegU8(reg, immValue)`: put a SHR instruction\n\n-   `putXorRegReg(dstReg, srcReg)`: put an XOR instruction\n\n-   `putMovRegReg(dstReg, srcReg)`: put a MOV instruction\n\n-   `putMovRegU32(dstReg, immValue)`: put a MOV instruction\n\n-   `putMovRegU64(dstReg, immValue)`: put a MOV instruction\n\n-   `putMovRegAddress(dstReg, address)`: put a MOV instruction\n\n-   `putMovRegPtrU32(dstReg, immValue)`: put a MOV instruction\n\n-   `putMovRegOffsetPtrU32(dstReg, dstOffset, immValue)`: put a MOV instruction\n\n-   `putMovRegPtrReg(dstReg, srcReg)`: put a MOV instruction\n\n-   `putMovRegOffsetPtrReg(dstReg, dstOffset, srcReg)`: put a MOV instruction\n\n-   `putMovRegRegPtr(dstReg, srcReg)`: put a MOV instruction\n\n-   `putMovRegRegOffsetPtr(dstReg, srcReg, srcOffset)`: put a MOV instruction\n\n-   `putMovRegBaseIndexScaleOffsetPtr(dstReg, baseReg, indexReg, scale, offset)`: put a MOV instruction\n\n-   `putMovRegNearPtr(dstReg, srcAddress)`: put a MOV instruction\n\n-   `putMovNearPtrReg(dstAddress, srcReg)`: put a MOV instruction\n\n-   `putMovFsU32PtrReg(fsOffset, srcReg)`: put a MOV FS instruction\n\n-   `putMovRegFsU32Ptr(dstReg, fsOffset)`: put a MOV FS instruction\n\n-   `putMovFsRegPtrReg(fsOffset, srcReg)`: put a MOV FS instruction\n\n-   `putMovRegFsRegPtr(dstReg, fsOffset)`: put a MOV FS instruction\n\n-   `putMovGsU32PtrReg(fsOffset, srcReg)`: put a MOV GS instruction\n\n-   `putMovRegGsU32Ptr(dstReg, fsOffset)`: put a MOV GS instruction\n\n-   `putMovGsRegPtrReg(gsOffset, srcReg)`: put a MOV GS instruction\n\n-   `putMovRegGsRegPtr(dstReg, gsOffset)`: put a MOV GS instruction\n\n-   `putMovqXmm0EspOffsetPtr(offset)`: put a MOVQ XMM0 ESP instruction\n\n-   `putMovqEaxOffsetPtrXmm0(offset)`: put a MOVQ EAX XMM0 instruction\n\n-   `putMovdquXmm0EspOffsetPtr(offset)`: put a MOVDQU XMM0 ESP instruction\n\n-   `putMovdquEaxOffsetPtrXmm0(offset)`: put a MOVDQU EAX XMM0 instruction\n\n-   `putLeaRegRegOffset(dstReg, srcReg, srcOffset)`: put a LEA instruction\n\n-   `putXchgRegRegPtr(leftReg, rightReg)`: put an XCHG instruction\n\n-   `putPushU32(immValue)`: put a PUSH instruction\n\n-   `putPushNearPtr(address)`: put a PUSH instruction\n\n-   `putPushReg(reg)`: put a PUSH instruction\n\n-   `putPopReg(reg)`: put a POP instruction\n\n-   `putPushImmPtr(immPtr)`: put a PUSH instruction\n\n-   `putPushax()`: put a PUSHAX instruction\n\n-   `putPopax()`: put a POPAX instruction\n\n-   `putPushfx()`: put a PUSHFX instruction\n\n-   `putPopfx()`: put a POPFX instruction\n\n-   `putSahf()`: put a SAHF instruction\n\n-   `putLahf()`: put a LAHF instruction\n\n-   `putTestRegReg(regA, regB)`: put a TEST instruction\n\n-   `putTestRegU32(reg, immValue)`: put a TEST instruction\n\n-   `putCmpRegI32(reg, immValue)`: put a CMP instruction\n\n-   `putCmpRegOffsetPtrReg(regA, offset, regB)`: put a CMP instruction\n\n-   `putCmpImmPtrImmU32(immPtr, immValue)`: put a CMP instruction\n\n-   `putCmpRegReg(regA, regB)`: put a CMP instruction\n\n-   `putClc()`: put a CLC instruction\n\n-   `putStc()`: put a STC instruction\n\n-   `putCld()`: put a CLD instruction\n\n-   `putStd()`: put a STD instruction\n\n-   `putCpuid()`: put a CPUID instruction\n\n-   `putLfence()`: put an LFENCE instruction\n\n-   `putRdtsc()`: put an RDTSC instruction\n\n-   `putPause()`: put a PAUSE instruction\n\n-   `putNop()`: put a NOP instruction\n\n-   `putBreakpoint()`: put an OS/architecture-specific breakpoint instruction\n\n-   `putPadding(n)`: put `n` guard instruction\n\n-   `putNopPadding(n)`: put `n` NOP instructions\n\n-   `putFxsaveRegPtr(reg)`: put a FXSAVE instruction\n\n-   `putFxrstorRegPtr(reg)`: put a FXRSTOR instruction\n\n-   `putU8(value)`: put a uint8\n\n-   `putS8(value)`: put an int8\n\n-   `putBytes(data)`: put raw data from the provided **[ArrayBuffer](#arraybuffer)**\n\n\n### X86Relocator\n\n+   `new X86Relocator(inputCode, output)`: create a new code relocator for\n    copying x86 instructions from one memory location to another, taking\n    care to adjust position-dependent instructions accordingly.\n    The source address is specified by `inputCode`, a **[NativePointer](#nativepointer)**.\n    The destination is given by `output`, an **[X86Writer](#x86writer)** pointed\n    at the desired target memory address.\n\n-   `reset(inputCode, output)`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `input`: latest **[Instruction](#instruction)** read so far. Starts out `null`\n    and changes on every call to [`readOne()`](#x86relocator-readone).\n\n-   `eob`: boolean indicating whether end-of-block has been reached, i.e. we've\n    reached a branch of any kind, like CALL, JMP, BL, RET.\n\n-   `eoi`: boolean indicating whether end-of-input has been reached, e.g. we've\n    reached JMP/B/RET, an instruction after which there may or may not be valid\n    code.\n\n-   `readOne()`: read the next instruction into the relocator's internal buffer\n    and return the number of bytes read so far, including previous calls.\n    You may keep calling this method to keep buffering, or immediately call\n    either [`writeOne()`](#x86relocator-writeone) or [`skipOne()`](#x86relocator-skipone).\n    Or, you can buffer up until the desired point and then call [`writeAll()`](#x86relocator-writeall).\n    Returns zero when end-of-input is reached, which means the `eoi` property is\n    now `true`.\n    {: #x86relocator-readone}\n\n-   `peekNextWriteInsn()`: peek at the next **[Instruction](#instruction)** to be\n    written or skipped\n\n-   `peekNextWriteSource()`: peek at the address of the next instruction to be\n    written or skipped\n\n-   `skipOne()`: skip the instruction that would have been written next\n    {: #x86relocator-skipone}\n\n-   `skipOneNoLabel()`: skip the instruction that would have been written next,\n    but without a label for internal use. This breaks relocation of branches to\n    locations inside the relocated range, and is an optimization for use-cases\n    where all branches are rewritten (e.g. Frida's **[Stalker](#stalker)**).\n\n-   `writeOne()`: write the next buffered instruction\n    {: #x86relocator-writeone}\n\n-   `writeOneNoLabel()`: write the next buffered instruction, but without a\n    label for internal use. This breaks relocation of branches to locations\n    inside the relocated range, and is an optimization for use-cases where all\n    branches are rewritten (e.g. Frida's **[Stalker](#stalker)**).\n\n-   `writeAll()`: write all buffered instructions\n    {: #x86relocator-writeall}\n\n\n### x86 enum types\n\n-   Register: `xax` `xcx` `xdx` `xbx` `xsp` `xbp` `xsi` `xdi` `eax` `ecx` `edx`\n    `ebx` `esp` `ebp` `esi` `edi` `rax` `rcx` `rdx` `rbx` `rsp` `rbp` `rsi`\n    `rdi` `r8` `r9` `r10` `r11` `r12` `r13` `r14` `r15` `r8d` `r9d` `r10d`\n    `r11d` `r12d` `r13d` `r14d` `r15d` `xip` `eip` `rip`\n-   InstructionId: `jo` `jno` `jb` `jae` `je` `jne` `jbe` `ja` `js` `jns` `jp`\n    `jnp` `jl` `jge` `jle` `jg` `jcxz` `jecxz` `jrcxz`\n-   BranchHint: `no-hint` `likely` `unlikely`\n-   PointerTarget: `byte` `dword` `qword`\n\n\n### ArmWriter\n\n+   `new ArmWriter(codeAddress[, { pc: ptr('0x1234') }])`: create a new code\n    writer for generating ARM machine code written directly to memory at\n    `codeAddress`, specified as a **[NativePointer](#nativepointer)**.\n    The second argument is an optional options object where the initial program\n    counter may be specified, which is useful when generating code to a scratch\n    buffer. This is essential when using [`Memory.patchCode()`](#memory-patchcode)\n    on iOS, which may provide you with a temporary location that later gets mapped\n    into memory at the intended memory location.\n\n-   `reset(codeAddress[, { pc: ptr('0x1234') }])`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `flush()`: resolve label references and write pending data to memory. You\n    should always call this once you've finished generating code. It is usually\n    also desirable to do this between pieces of unrelated code, e.g. when\n    generating multiple functions in one go.\n\n-   `base`: memory location of the first byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `code`: memory location of the next byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `pc`: program counter at the next byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `offset`: current offset as a JavaScript Number\n\n-   `skip(nBytes)`: skip `nBytes`\n\n-   `putLabel(id)`: put a label at the current position, where `id` is a string\n    that may be referenced in past and future `put*Label()` calls\n    {: #armwriter-putlabel}\n\n-   `putCallAddressWithArguments(func, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putCallReg(reg)`: put a CALL instruction\n\n-   `putCallRegWithArguments(reg, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    NativePointer specifying the immediate value.\n\n-   `putBranchAddress(address)`: put code needed for branching/jumping to the\n    given address\n\n-   `canBranchDirectlyBetween(from, to)`: determine whether a direct branch is\n    possible between the two given memory locations\n\n-   `putBImm(target)`: put a B instruction\n\n-   `putBCondImm(cc, target)`: put a B COND instruction\n\n-   `putBLabel(labelId)`: put a B instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#armwriter-putlabel)\n\n-   `putBCondLabel(cc, labelId)`: put a B COND instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#armwriter-putlabel)\n\n-   `putBlImm(target)`: put a BL instruction\n\n-   `putBlxImm(target)`: put a BLX instruction\n\n-   `putBlLabel(labelId)`: put a BL instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#armwriter-putlabel)\n\n-   `putBxReg(reg)`: put a BX instruction\n\n-   `putBlReg(reg)`: put a BL instruction\n\n-   `putBlxReg(reg)`: put a BLX instruction\n\n-   `putRet()`: put a RET instruction\n\n-   `putVpushRange(firstReg, lastReg)`: put a VPUSH RANGE instruction\n\n-   `putVpopRange(firstReg, lastReg)`: put a VPOP RANGE instruction\n\n-   `putLdrRegAddress(reg, address)`: put an LDR instruction\n\n-   `putLdrRegU32(reg, val)`: put an LDR instruction\n\n-   `putLdrRegReg(dstReg, srcReg)`: put an LDR instruction\n\n-   `putLdrRegRegOffset(dstReg, srcReg, srcOffset)`: put an LDR instruction\n\n-   `putLdrCondRegRegOffset(cc, dstReg, srcReg, srcOffset)`: put an LDR COND instruction\n\n-   `putLdmiaRegMask(reg, mask)`: put an LDMIA MASK instruction\n\n-   `putLdmiaRegMaskWb(reg, mask)`: put an LDMIA MASK WB instruction\n\n-   `putStrRegReg(srcReg, dstReg)`: put a STR instruction\n\n-   `putStrRegRegOffset(srcReg, dstReg, dstOffset)`: put a STR instruction\n\n-   `putStrCondRegRegOffset(cc, srcReg, dstReg, dstOffset)`: put a STR COND instruction\n\n-   `putMovRegReg(dstReg, srcReg)`: put a MOV instruction\n\n-   `putMovRegRegShift(dstReg, srcReg, shift, shiftValue)`: put a MOV SHIFT instruction\n\n-   `putMovRegCpsr(reg)`: put a MOV CPSR instruction\n\n-   `putMovCpsrReg(reg)`: put a MOV CPSR instruction\n\n-   `putAddRegU16(dstReg, val)`: put an ADD U16 instruction\n\n-   `putAddRegU32(dstReg, val)`: put an ADD instruction\n\n-   `putAddRegRegImm(dstReg, srcReg, immVal)`: put an ADD instruction\n\n-   `putAddRegRegReg(dstReg, srcReg1, srcReg2)`: put an ADD instruction\n\n-   `putAddRegRegRegShift(dstReg, srcReg1, srcReg2, shift, shiftValue)`: put an ADD SHIFT instruction\n\n-   `putSubRegU16(dstReg, val)`: put a SUB U16 instruction\n\n-   `putSubRegU32(dstReg, val)`: put a SUB instruction\n\n-   `putSubRegRegImm(dstReg, srcReg, immVal)`: put a SUB instruction\n\n-   `putSubRegRegReg(dstReg, srcReg1, srcReg2)`: put a SUB instruction\n\n-   `putRsbRegRegImm(dstReg, srcReg, immVal)`: put a RSB instruction\n\n-   `putAndsRegRegImm(dstReg, srcReg, immVal)`: put an ANDS instruction\n\n-   `putCmpRegImm(dstReg, immVal)`: put a CMP instruction\n\n-   `putNop()`: put a NOP instruction\n\n-   `putBreakpoint()`: put an OS/architecture-specific breakpoint instruction\n\n-   `putBrkImm(imm)`: put a BRK instruction\n\n-   `putInstruction(insn)`: put a raw instruction as a JavaScript Number\n\n-   `putBytes(data)`: put raw data from the provided **[ArrayBuffer](#arraybuffer)**\n\n\n### ArmRelocator\n\n+   `new ArmRelocator(inputCode, output)`: create a new code relocator for\n    copying ARM instructions from one memory location to another, taking\n    care to adjust position-dependent instructions accordingly.\n    The source address is specified by `inputCode`, a **[NativePointer](#nativepointer)**.\n    The destination is given by `output`, an **[ArmWriter](#armwriter)** pointed\n    at the desired target memory address.\n\n-   `reset(inputCode, output)`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `input`: latest **[Instruction](#instruction)** read so far. Starts out `null`\n    and changes on every call to [`readOne()`](#armrelocator-readone).\n\n-   `eob`: boolean indicating whether end-of-block has been reached, i.e. we've\n    reached a branch of any kind, like CALL, JMP, BL, RET.\n\n-   `eoi`: boolean indicating whether end-of-input has been reached, e.g. we've\n    reached JMP/B/RET, an instruction after which there may or may not be valid\n    code.\n\n-   `readOne()`: read the next instruction into the relocator's internal buffer\n    and return the number of bytes read so far, including previous calls.\n    You may keep calling this method to keep buffering, or immediately call\n    either [`writeOne()`](#armrelocator-writeone) or [`skipOne()`](#armrelocator-skipone).\n    Or, you can buffer up until the desired point and then call [`writeAll()`](#armrelocator-writeall).\n    Returns zero when end-of-input is reached, which means the `eoi` property is\n    now `true`.\n    {: #armrelocator-readone}\n\n-   `peekNextWriteInsn()`: peek at the next **[Instruction](#instruction)** to be\n    written or skipped\n\n-   `peekNextWriteSource()`: peek at the address of the next instruction to be\n    written or skipped\n\n-   `skipOne()`: skip the instruction that would have been written next\n    {: #armrelocator-skipone}\n\n-   `writeOne()`: write the next buffered instruction\n    {: #armrelocator-writeone}\n\n-   `writeAll()`: write all buffered instructions\n    {: #armrelocator-writeall}\n\n\n### ThumbWriter\n\n+   `new ThumbWriter(codeAddress[, { pc: ptr('0x1234') }])`: create a new code\n    writer for generating ARM machine code written directly to memory at\n    `codeAddress`, specified as a **[NativePointer](#nativepointer)**.\n    The second argument is an optional options object where the initial program\n    counter may be specified, which is useful when generating code to a scratch\n    buffer. This is essential when using [`Memory.patchCode()`](#memory-patchcode)\n    on iOS, which may provide you with a temporary location that later gets mapped\n    into memory at the intended memory location.\n\n-   `reset(codeAddress[, { pc: ptr('0x1234') }])`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `flush()`: resolve label references and write pending data to memory. You\n    should always call this once you've finished generating code. It is usually\n    also desirable to do this between pieces of unrelated code, e.g. when\n    generating multiple functions in one go.\n\n-   `base`: memory location of the first byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `code`: memory location of the next byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `pc`: program counter at the next byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `offset`: current offset as a JavaScript Number\n\n-   `skip(nBytes)`: skip `nBytes`\n\n-   `putLabel(id)`: put a label at the current position, where `id` is a string\n    that may be referenced in past and future `put*Label()` calls\n    {: #thumbwriter-putlabel}\n\n-   `commitLabel(id)`: commit the first pending reference to the given label,\n    returning `true` on success. Returns `false` if the given label hasn't been\n    defined yet, or there are no more pending references to it.\n\n-   `putCallAddressWithArguments(func, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putCallRegWithArguments(reg, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putBranchAddress(address)`: put code needed for branching/jumping to the\n    given address\n\n-   `canBranchDirectlyBetween(from, to)`: determine whether a direct branch is\n    possible between the two given memory locations\n\n-   `putBImm(target)`: put a B instruction\n\n-   `putBLabel(labelId)`: put a B instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#thumbwriter-putlabel)\n\n-   `putBLabelWide(labelId)`: put a B WIDE instruction\n\n-   `putBxReg(reg)`: put a BX instruction\n\n-   `putBlImm(target)`: put a BL instruction\n\n-   `putBlLabel(labelId)`: put a BL instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#thumbwriter-putlabel)\n\n-   `putBlxImm(target)`: put a BLX instruction\n\n-   `putBlxReg(reg)`: put a BLX instruction\n\n-   `putCmpRegImm(reg, immValue)`: put a CMP instruction\n\n-   `putBeqLabel(labelId)`: put a BEQ instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#thumbwriter-putlabel)\n\n-   `putBneLabel(labelId)`: put a BNE instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#thumbwriter-putlabel)\n\n-   `putBCondLabel(cc, labelId)`: put a B COND instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#thumbwriter-putlabel)\n\n-   `putBCondLabelWide(cc, labelId)`: put a B COND WIDE instruction\n\n-   `putCbzRegLabel(reg, labelId)`: put a CBZ instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#thumbwriter-putlabel)\n\n-   `putCbnzRegLabel(reg, labelId)`: put a CBNZ instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#thumbwriter-putlabel)\n\n-   `putPushRegs(regs)`: put a PUSH instruction with the specified registers,\n    specified as a JavaScript array where each element is a string specifying\n    the register name.\n\n-   `putPopRegs(regs)`: put a POP instruction with the specified registers,\n    specified as a JavaScript array where each element is a string specifying\n    the register name.\n\n-   `putVpushRange(firstReg, lastReg)`: put a VPUSH RANGE instruction\n\n-   `putVpopRange(firstReg, lastReg)`: put a VPOP RANGE instruction\n\n-   `putLdrRegAddress(reg, address)`: put an LDR instruction\n\n-   `putLdrRegU32(reg, val)`: put an LDR instruction\n\n-   `putLdrRegReg(dstReg, srcReg)`: put an LDR instruction\n\n-   `putLdrRegRegOffset(dstReg, srcReg, srcOffset)`: put an LDR instruction\n\n-   `putLdrbRegReg(dstReg, srcReg)`: put an LDRB instruction\n\n-   `putVldrRegRegOffset(dstReg, srcReg, srcOffset)`: put a VLDR instruction\n\n-   `putLdmiaRegMask(reg, mask)`: put an LDMIA MASK instruction\n\n-   `putStrRegReg(srcReg, dstReg)`: put a STR instruction\n\n-   `putStrRegRegOffset(srcReg, dstReg, dstOffset)`: put a STR instruction\n\n-   `putMovRegReg(dstReg, srcReg)`: put a MOV instruction\n\n-   `putMovRegU8(dstReg, immValue)`: put a MOV instruction\n\n-   `putMovRegCpsr(reg)`: put a MOV CPSR instruction\n\n-   `putMovCpsrReg(reg)`: put a MOV CPSR instruction\n\n-   `putAddRegImm(dstReg, immValue)`: put an ADD instruction\n\n-   `putAddRegReg(dstReg, srcReg)`: put an ADD instruction\n\n-   `putAddRegRegReg(dstReg, leftReg, rightReg)`: put an ADD instruction\n\n-   `putAddRegRegImm(dstReg, leftReg, rightValue)`: put an ADD instruction\n\n-   `putSubRegImm(dstReg, immValue)`: put a SUB instruction\n\n-   `putSubRegReg(dstReg, srcReg)`: put a SUB instruction\n\n-   `putSubRegRegReg(dstReg, leftReg, rightReg)`: put a SUB instruction\n\n-   `putSubRegRegImm(dstReg, leftReg, rightValue)`: put a SUB instruction\n\n-   `putAndRegRegImm(dstReg, leftReg, rightValue)`: put an AND instruction\n\n-   `putOrRegRegImm(dstReg, leftReg, rightValue)`: put an OR instruction\n\n-   `putLslRegRegImm(dstReg, leftReg, rightValue)`: put a LSL instruction\n\n-   `putLslsRegRegImm(dstReg, leftReg, rightValue)`: put a LSLS instruction\n\n-   `putLsrsRegRegImm(dstReg, leftReg, rightValue)`: put a LSRS instruction\n\n-   `putMrsRegReg(dstReg, srcReg)`: put a MRS instruction\n\n-   `putMsrRegReg(dstReg, srcReg)`: put a MSR instruction\n\n-   `putNop()`: put a NOP instruction\n\n-   `putBkptImm(imm)`: put a BKPT instruction\n\n-   `putBreakpoint()`: put an OS/architecture-specific breakpoint instruction\n\n-   `putInstruction(insn)`: put a raw instruction as a JavaScript Number\n\n-   `putInstructionWide(upper, lower)`: put a raw Thumb-2 instruction from\n    two JavaScript Number values\n\n-   `putBytes(data)`: put raw data from the provided **[ArrayBuffer](#arraybuffer)**\n\n\n### ThumbRelocator\n\n+   `new ThumbRelocator(inputCode, output)`: create a new code relocator for\n    copying ARM instructions from one memory location to another, taking\n    care to adjust position-dependent instructions accordingly.\n    The source address is specified by `inputCode`, a **[NativePointer](#nativepointer)**.\n    The destination is given by `output`, a **[ThumbWriter](#thumbwriter)** pointed\n    at the desired target memory address.\n\n-   `reset(inputCode, output)`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `input`: latest **[Instruction](#instruction)** read so far. Starts out `null`\n    and changes on every call to [`readOne()`](#thumbrelocator-readone).\n\n-   `eob`: boolean indicating whether end-of-block has been reached, i.e. we've\n    reached a branch of any kind, like CALL, JMP, BL, RET.\n\n-   `eoi`: boolean indicating whether end-of-input has been reached, e.g. we've\n    reached JMP/B/RET, an instruction after which there may or may not be valid\n    code.\n\n-   `readOne()`: read the next instruction into the relocator's internal buffer\n    and return the number of bytes read so far, including previous calls.\n    You may keep calling this method to keep buffering, or immediately call\n    either [`writeOne()`](#thumbrelocator-writeone) or [`skipOne()`](#thumbrelocator-skipone).\n    Or, you can buffer up until the desired point and then call [`writeAll()`](#thumbrelocator-writeall).\n    Returns zero when end-of-input is reached, which means the `eoi` property is\n    now `true`.\n    {: #thumbrelocator-readone}\n\n-   `peekNextWriteInsn()`: peek at the next **[Instruction](#instruction)** to be\n    written or skipped\n\n-   `peekNextWriteSource()`: peek at the address of the next instruction to be\n    written or skipped\n\n-   `skipOne()`: skip the instruction that would have been written next\n    {: #thumbrelocator-skipone}\n\n-   `writeOne()`: write the next buffered instruction\n    {: #thumbrelocator-writeone}\n\n-   `copyOne()`: copy out the next buffered instruction without advancing the\n    output cursor, allowing the same instruction to be written out multiple\n    times\n\n-   `writeAll()`: write all buffered instructions\n    {: #thumbrelocator-writeall}\n\n\n### ARM enum types\n\n-   Register: `r0` `r1` `r2` `r3` `r4` `r5` `r6` `r7` `r8` `r9` `r10` `r11`\n    `r12` `r13` `r14` `r15` `sp` `lr` `sb` `sl` `fp` `ip` `pc` `s0` `s1` `s2`\n    `s3` `s4` `s5` `s6` `s7` `s8` `s9` `s10` `s11` `s12` `s13` `s14` `s15`\n    `s16` `s17` `s18` `s19` `s20` `s21` `s22` `s23` `s24` `s25` `s26` `s27`\n    `s28` `s29` `s30` `s31` `d0` `d1` `d2` `d3` `d4` `d5` `d6` `d7` `d8` `d9`\n    `d10` `d11` `d12` `d13` `d14` `d15` `d16` `d17` `d18` `d19` `d20` `d21`\n    `d22` `d23` `d24` `d25` `d26` `d27` `d28` `d29` `d30` `d31` `q0` `q1` `q2`\n    `q3` `q4` `q5` `q6` `q7` `q8` `q9` `q10` `q11` `q12` `q13` `q14` `q15`\n-   SystemRegister: `apsr-nzcvq`\n-   ConditionCode: `eq` `ne` `hs` `lo` `mi` `pl` `vs` `vc` `hi` `ls` `ge` `lt`\n    `gt` `le` `al`\n-   Shifter: `asr` `lsl` `lsr` `ror` `rrx` `asr-reg` `lsl-reg` `lsr-reg`\n    `ror-reg` `rrx-reg`\n\n\n### Arm64Writer\n\n+   `new Arm64Writer(codeAddress[, { pc: ptr('0x1234') }])`: create a new code\n    writer for generating AArch64 machine code written directly to memory at\n    `codeAddress`, specified as a **[NativePointer](#nativepointer)**.\n    The second argument is an optional options object where the initial program\n    counter may be specified, which is useful when generating code to a scratch\n    buffer. This is essential when using [`Memory.patchCode()`](#memory-patchcode)\n    on iOS, which may provide you with a temporary location that later gets mapped\n    into memory at the intended memory location.\n\n-   `reset(codeAddress[, { pc: ptr('0x1234') }])`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `flush()`: resolve label references and write pending data to memory. You\n    should always call this once you've finished generating code. It is usually\n    also desirable to do this between pieces of unrelated code, e.g. when\n    generating multiple functions in one go.\n\n-   `base`: memory location of the first byte of output, as a NativePointer\n\n-   `code`: memory location of the next byte of output, as a NativePointer\n\n-   `pc`: program counter at the next byte of output, as a NativePointer\n\n-   `offset`: current offset as a JavaScript Number\n\n-   `skip(nBytes)`: skip `nBytes`\n\n-   `putLabel(id)`: put a label at the current position, where `id` is a string\n    that may be referenced in past and future `put*Label()` calls\n    {: #arm64writer-putlabel}\n\n-   `putCallAddressWithArguments(func, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putCallRegWithArguments(reg, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putBranchAddress(address)`: put code needed for branching/jumping to the\n    given address\n\n-   `canBranchDirectlyBetween(from, to)`: determine whether a direct branch is\n    possible between the two given memory locations\n\n-   `putBImm(address)`: put a B instruction\n\n-   `putBLabel(labelId)`: put a B instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#arm64writer-putlabel)\n\n-   `putBCondLabel(cc, labelId)`: put a B COND instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#arm64writer-putlabel)\n\n-   `putBlImm(address)`: put a BL instruction\n\n-   `putBlLabel(labelId)`: put a BL instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#arm64writer-putlabel)\n\n-   `putBrReg(reg)`: put a BR instruction\n\n-   `putBrRegNoAuth(reg)`: put a BR instruction expecting a raw pointer\n    without any authentication bits\n\n-   `putBlrReg(reg)`: put a BLR instruction\n\n-   `putBlrRegNoAuth(reg)`: put a BLR instruction expecting a raw pointer\n    without any authentication bits\n\n-   `putRet()`: put a RET instruction\n\n-   `putRetReg(reg)`: put a RET instruction\n\n-   `putCbzRegImm(reg, target)`: put a CBZ instruction\n\n-   `putCbnzRegImm(reg, target)`: put a CBNZ instruction\n\n-   `putCbzRegLabel(reg, labelId)`: put a CBZ instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#arm64writer-putlabel)\n\n-   `putCbnzRegLabel(reg, labelId)`: put a CBNZ instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#arm64writer-putlabel)\n\n-   `putTbzRegImmImm(reg, bit, target)`: put a TBZ instruction\n\n-   `putTbnzRegImmImm(reg, bit, target)`: put a TBNZ instruction\n\n-   `putTbzRegImmLabel(reg, bit, labelId)`: put a TBZ instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#arm64writer-putlabel)\n\n-   `putTbnzRegImmLabel(reg, bit, labelId)`: put a TBNZ instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#arm64writer-putlabel)\n\n-   `putPushRegReg(regA, regB)`: put a PUSH instruction\n\n-   `putPopRegReg(regA, regB)`: put a POP instruction\n\n-   `putPushAllXRegisters()`: put code needed for pushing all X registers on the stack\n\n-   `putPopAllXRegisters()`: put code needed for popping all X registers off the stack\n\n-   `putPushAllQRegisters()`: put code needed for pushing all Q registers on the stack\n\n-   `putPopAllQRegisters()`: put code needed for popping all Q registers off the stack\n\n-   `putLdrRegAddress(reg, address)`: put an LDR instruction\n\n-   `putLdrRegU32(reg, val)`: put an LDR instruction\n\n-   `putLdrRegU64(reg, val)`: put an LDR instruction\n\n-   `putLdrRegU32Ptr(reg, srcAddress)`: put an LDR instruction\n\n-   `putLdrRegU64Ptr(reg, srcAddress)`: put an LDR instruction\n\n-   `putLdrRegRef(reg)`: put an LDR instruction with a dangling data reference,\n    returning an opaque ref value that should be passed to [`putLdrRegValue()`](#arm64writer-putldrregvalue)\n    at the desired location\n    {: #arm64writer-putldrregref}\n\n-   `putLdrRegValue(ref, value)`: put the value and update the LDR instruction\n    from a previous [`putLdrRegRef()`](#arm64writer-putldrregref)\n    {: #arm64writer-putldrregvalue}\n\n-   `putLdrRegReg(dstReg, srcReg)`: put an LDR instruction\n\n-   `putLdrRegRegOffset(dstReg, srcReg, srcOffset)`: put an LDR instruction\n\n-   `putLdrRegRegOffsetMode(dstReg, srcReg, srcOffset, mode)`: put an LDR MODE instruction\n\n-   `putLdrswRegRegOffset(dstReg, srcReg, srcOffset)`: put an LDRSW instruction\n\n-   `putAdrpRegAddress(reg, address)`: put an ADRP instruction\n\n-   `putStrRegReg(srcReg, dstReg)`: put a STR instruction\n\n-   `putStrRegRegOffset(srcReg, dstReg, dstOffset)`: put a STR instruction\n\n-   `putStrRegRegOffsetMode(srcReg, dstReg, dstOffset, mode)`: put a STR MODE instruction\n\n-   `putLdpRegRegRegOffset(regA, regB, regSrc, srcOffset, mode)`: put an LDP instruction\n\n-   `putStpRegRegRegOffset(regA, regB, regDst, dstOffset, mode)`: put a STP instruction\n\n-   `putMovRegReg(dstReg, srcReg)`: put a MOV instruction\n\n-   `putMovRegNzcv(reg)`: put a MOV NZCV instruction\n\n-   `putMovNzcvReg(reg)`: put a MOV NZCV instruction\n\n-   `putUxtwRegReg(dstReg, srcReg)`: put an UXTW instruction\n\n-   `putAddRegRegImm(dstReg, leftReg, rightValue)`: put an ADD instruction\n\n-   `putAddRegRegReg(dstReg, leftReg, rightReg)`: put an ADD instruction\n\n-   `putSubRegRegImm(dstReg, leftReg, rightValue)`: put a SUB instruction\n\n-   `putSubRegRegReg(dstReg, leftReg, rightReg)`: put a SUB instruction\n\n-   `putAndRegRegImm(dstReg, leftReg, rightValue)`: put an AND instruction\n\n-   `putEorRegRegReg(dstReg, leftReg, rightReg)`: put an EOR instruction\n\n-   `putUbfm(dstReg, srcReg, imms, immr)`: put an UBFM instruction\n\n-   `putLslRegImm(dstReg, srcReg, shift)`: put a LSL instruction\n\n-   `putLsrRegImm(dstReg, srcReg, shift)`: put a LSR instruction\n\n-   `putTstRegImm(reg, immValue)`: put a TST instruction\n\n-   `putCmpRegReg(regA, regB)`: put a CMP instruction\n\n-   `putXpaciReg(reg)`: put an XPACI instruction\n\n-   `putNop()`: put a NOP instruction\n\n-   `putBrkImm(imm)`: put a BRK instruction\n\n-   `putMrs(dstReg, systemReg)`: put a MRS instruction\n\n-   `putInstruction(insn)`: put a raw instruction as a JavaScript Number\n\n-   `putBytes(data)`: put raw data from the provided **[ArrayBuffer](#arraybuffer)**\n\n-   `sign(value)`: sign the given pointer value\n\n\n### Arm64Relocator\n\n+   `new Arm64Relocator(inputCode, output)`: create a new code relocator for\n    copying AArch64 instructions from one memory location to another, taking\n    care to adjust position-dependent instructions accordingly.\n    The source address is specified by `inputCode`, a **[NativePointer](#nativepointer)**.\n    The destination is given by `output`, an **[Arm64Writer](#arm64writer)** pointed\n    at the desired target memory address.\n\n-   `reset(inputCode, output)`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `input`: latest **[Instruction](#instruction)** read so far. Starts out `null`\n    and changes on every call to [`readOne()`](#arm64relocator-readone).\n\n-   `eob`: boolean indicating whether end-of-block has been reached, i.e. we've\n    reached a branch of any kind, like CALL, JMP, BL, RET.\n\n-   `eoi`: boolean indicating whether end-of-input has been reached, e.g. we've\n    reached JMP/B/RET, an instruction after which there may or may not be valid\n    code.\n\n-   `readOne()`: read the next instruction into the relocator's internal buffer\n    and return the number of bytes read so far, including previous calls.\n    You may keep calling this method to keep buffering, or immediately call\n    either [`writeOne()`](#arm64relocator-writeone) or [`skipOne()`](#arm64relocator-skipone).\n    Or, you can buffer up until the desired point and then call [`writeAll()`](#arm64relocator-writeall).\n    Returns zero when end-of-input is reached, which means the `eoi` property is\n    now `true`.\n    {: #arm64relocator-readone}\n\n-   `peekNextWriteInsn()`: peek at the next **[Instruction](#instruction)** to be\n    written or skipped\n\n-   `peekNextWriteSource()`: peek at the address of the next instruction to be\n    written or skipped\n\n-   `skipOne()`: skip the instruction that would have been written next\n    {: #arm64relocator-skipone}\n\n-   `writeOne()`: write the next buffered instruction\n    {: #arm64relocator-writeone}\n\n-   `writeAll()`: write all buffered instructions\n    {: #arm64relocator-writeall}\n\n\n### AArch64 enum types\n\n-   Register: `x0` `x1` `x2` `x3` `x4` `x5` `x6` `x7` `x8` `x9` `x10` `x11`\n    `x12` `x13` `x14` `x15` `x16` `x17` `x18` `x19` `x20` `x21` `x22` `x23`\n    `x24` `x25` `x26` `x27` `x28` `x29` `x30` `w0` `w1` `w2` `w3` `w4` `w5`\n    `w6` `w7` `w8` `w9` `w10` `w11` `w12` `w13` `w14` `w15` `w16` `w17` `w18`\n    `w19` `w20` `w21` `w22` `w23` `w24` `w25` `w26` `w27` `w28` `w29` `w30`\n    `sp` `lr` `fp` `wsp` `wzr` `xzr` `nzcv` `ip0` `ip1` `s0` `s1` `s2` `s3`\n    `s4` `s5` `s6` `s7` `s8` `s9` `s10` `s11` `s12` `s13` `s14` `s15` `s16`\n    `s17` `s18` `s19` `s20` `s21` `s22` `s23` `s24` `s25` `s26` `s27` `s28`\n    `s29` `s30` `s31` `d0` `d1` `d2` `d3` `d4` `d5` `d6` `d7` `d8` `d9` `d10`\n    `d11` `d12` `d13` `d14` `d15` `d16` `d17` `d18` `d19` `d20` `d21` `d22`\n    `d23` `d24` `d25` `d26` `d27` `d28` `d29` `d30` `d31` `q0` `q1` `q2` `q3`\n    `q4` `q5` `q6` `q7` `q8` `q9` `q10` `q11` `q12` `q13` `q14` `q15` `q16`\n    `q17` `q18` `q19` `q20` `q21` `q22` `q23` `q24` `q25` `q26` `q27` `q28`\n    `q29` `q30` `q31`\n-   ConditionCode: `eq` `ne` `hs` `lo` `mi` `pl` `vs` `vc` `hi` `ls` `ge` `lt`\n    `gt` `le` `al` `nv`\n-   IndexMode: `post-adjust` `signed-offset` `pre-adjust`\n\n\n### MipsWriter\n\n+   `new MipsWriter(codeAddress[, { pc: ptr('0x1234') }])`: create a new code\n    writer for generating MIPS machine code written directly to memory at\n    `codeAddress`, specified as a **[NativePointer](#nativepointer)**.\n    The second argument is an optional options object where the initial program\n    counter may be specified, which is useful when generating code to a scratch\n    buffer. This is essential when using [`Memory.patchCode()`](#memory-patchcode)\n    on iOS, which may provide you with a temporary location that later gets mapped\n    into memory at the intended memory location.\n\n-   `reset(codeAddress[, { pc: ptr('0x1234') }])`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `flush()`: resolve label references and write pending data to memory. You\n    should always call this once you've finished generating code. It is usually\n    also desirable to do this between pieces of unrelated code, e.g. when\n    generating multiple functions in one go.\n\n-   `base`: memory location of the first byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `code`: memory location of the next byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `pc`: program counter at the next byte of output, as a **[NativePointer](#nativepointer)**\n\n-   `offset`: current offset as a JavaScript Number\n\n-   `skip(nBytes)`: skip `nBytes`\n\n-   `putLabel(id)`: put a label at the current position, where `id` is a string\n    that may be referenced in past and future `put*Label()` calls\n    {: #mipswriter-putlabel}\n\n-   `putCallAddressWithArguments(func, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putCallRegWithArguments(reg, args)`: put code needed for calling a C\n    function with the specified `args`, specified as a JavaScript array where\n    each element is either a string specifying the register, or a Number or\n    **[NativePointer](#nativepointer)** specifying the immediate value.\n\n-   `putJAddress(address)`: put a J instruction\n\n-   `putJAddressWithoutNop(address)`: put a J WITHOUT NOP instruction\n\n-   `putJLabel(labelId)`: put a J instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#mipswriter-putlabel)\n\n-   `putJrReg(reg)`: put a JR instruction\n\n-   `putJalAddress(address)`: put a JAL instruction\n\n-   `putJalrReg(reg)`: put a JALR instruction\n\n-   `putBOffset(offset)`: put a B instruction\n\n-   `putBeqRegRegLabel(rightReg, leftReg, labelId)`: put a BEQ instruction\n    referencing `labelId`, defined by a past or future [`putLabel()`](#mipswriter-putlabel)\n\n-   `putRet()`: put a RET instruction\n\n-   `putLaRegAddress(reg, address)`: put a LA instruction\n\n-   `putLuiRegImm(reg, imm)`: put a LUI instruction\n\n-   `putDsllRegReg(dstReg, srcReg, amount)`: put a DSLL instruction\n\n-   `putOriRegRegImm(rt, rs, imm)`: put an ORI instruction\n\n-   `putLdRegRegOffset(dstReg, srcReg, srcOffset)`: put an LD instruction\n\n-   `putLwRegRegOffset(dstReg, srcReg, srcOffset)`: put a LW instruction\n\n-   `putSwRegRegOffset(srcReg, dstReg, dstOffset)`: put a SW instruction\n\n-   `putMoveRegReg(dstReg, srcReg)`: put a MOVE instruction\n\n-   `putAdduRegRegReg(dstReg, leftReg, rightReg)`: put an ADDU instruction\n\n-   `putAddiRegRegImm(dstReg, leftReg, imm)`: put an ADDI instruction\n\n-   `putAddiRegImm(dstReg, imm)`: put an ADDI instruction\n\n-   `putSubRegRegImm(dstReg, leftReg, imm)`: put a SUB instruction\n\n-   `putPushReg(reg)`: put a PUSH instruction\n\n-   `putPopReg(reg)`: put a POP instruction\n\n-   `putMfhiReg(reg)`: put a MFHI instruction\n\n-   `putMfloReg(reg)`: put a MFLO instruction\n\n-   `putMthiReg(reg)`: put a MTHI instruction\n\n-   `putMtloReg(reg)`: put a MTLO instruction\n\n-   `putNop()`: put a NOP instruction\n\n-   `putBreak()`: put a BREAK instruction\n\n-   `putPrologueTrampoline(reg, address)`: put a minimal sized trampoline for\n    vectoring to the given address\n\n-   `putInstruction(insn)`: put a raw instruction as a JavaScript Number\n\n-   `putBytes(data)`: put raw data from the provided **[ArrayBuffer](#arraybuffer)**\n\n\n### MipsRelocator\n\n+   `new MipsRelocator(inputCode, output)`: create a new code relocator for\n    copying MIPS instructions from one memory location to another, taking\n    care to adjust position-dependent instructions accordingly.\n    The source address is specified by `inputCode`, a **[NativePointer](#nativepointer)**.\n    The destination is given by `output`, a **[MipsWriter](#mipswriter)** pointed\n    at the desired target memory address.\n\n-   `reset(inputCode, output)`: recycle instance\n\n-   `dispose()`: eagerly clean up memory\n\n-   `input`: latest **[Instruction](#instruction)** read so far. Starts out `null`\n    and changes on every call to [`readOne()`](#mipsrelocator-readone).\n\n-   `eob`: boolean indicating whether end-of-block has been reached, i.e. we've\n    reached a branch of any kind, like CALL, JMP, BL, RET.\n\n-   `eoi`: boolean indicating whether end-of-input has been reached, e.g. we've\n    reached JMP/B/RET, an instruction after which there may or may not be valid\n    code.\n\n-   `readOne()`: read the next instruction into the relocator's internal buffer\n    and return the number of bytes read so far, including previous calls.\n    You may keep calling this method to keep buffering, or immediately call\n    either [`writeOne()`](#mipsrelocator-writeone) or [`skipOne()`](#mipsrelocator-skipone).\n    Or, you can buffer up until the desired point and then call [`writeAll()`](#mipsrelocator-writeall).\n    Returns zero when end-of-input is reached, which means the `eoi` property is\n    now `true`.\n    {: #mipsrelocator-readone}\n\n-   `peekNextWriteInsn()`: peek at the next **[Instruction](#instruction)** to be\n    written or skipped\n\n-   `peekNextWriteSource()`: peek at the address of the next instruction to be\n    written or skipped\n\n-   `skipOne()`: skip the instruction that would have been written next\n    {: #mipsrelocator-skipone}\n\n-   `writeOne()`: write the next buffered instruction\n    {: #mipsrelocator-writeone}\n\n-   `writeAll()`: write all buffered instructions\n    {: #mipsrelocator-writeall}\n\n\n### MIPS enum types\n\n-   Register: `v0` `v1` `a0` `a1` `a2` `a3` `t0` `t1` `t2` `t3` `t4` `t5` `t6`\n    `t7` `s0` `s1` `s2` `s3` `s4` `s5` `s6` `s7` `t8` `t9` `k0` `k1` `gp` `sp`\n    `fp` `s8` `ra` `hi` `lo` `zero` `at` `0` `1` `2` `3` `4` `5` `6` `7` `8`\n    `9` `10` `11` `12` `13` `14` `15` `16` `17` `18` `19` `20` `21` `22` `23`\n    `24` `25` `26` `27` `28` `29` `30` `31`\n\n---",
      "keywords": [
        "Instruction.parse",
        "API",
        "getExportByName",
        "address",
        "parse",
        "toString",
        "X86Writer",
        "ptr",
        "Memory.patchCode",
        "reset",
        "dispose",
        "flush",
        "putLabel",
        "Label",
        "putCallAddressWithArguments",
        "putCallAddressWithAlignedArguments",
        "putCallRegWithArguments",
        "putCallRegWithAlignedArguments",
        "putCallRegOffsetPtrWithArguments",
        "putCallAddress",
        "putCallReg",
        "putCallRegOffsetPtr",
        "putCallIndirect",
        "putCallIndirectLabel",
        "putCallNearLabel",
        "putLeave",
        "putRet",
        "putRetImm",
        "putJmpAddress",
        "putJmpShortLabel",
        "putJmpNearLabel",
        "putJmpReg",
        "putJmpRegPtr",
        "putJmpRegOffsetPtr",
        "putJmpNearPtr",
        "putJccShort",
        "putJccNear",
        "putJccShortLabel",
        "putJccNearLabel",
        "putAddRegImm",
        "putAddRegReg",
        "putAddRegNearPtr",
        "putSubRegImm",
        "putSubRegReg",
        "putSubRegNearPtr",
        "putIncReg",
        "putDecReg",
        "putIncRegPtr",
        "putDecRegPtr",
        "putLockXaddRegPtrReg"
      ],
      "examples": []
    },
    {
      "id": "others",
      "title": "Others",
      "category": "Other",
      "content": "## Others\n\n### Console\n\n+   `console.log(line)`, `console.warn(line)`, `console.error(line)`:\n    write `line` to the console of your Frida-based application. The exact\n    behavior depends on where [frida-core](https://github.com/frida/frida-core)\n    is integrated.\n    For example, this output goes to *stdout* or *stderr* when using Frida\n    through [frida-python](https://github.com/frida/frida-python),\n    **[qDebug](https://doc.qt.io/qt-5/qdebug.html)** when using\n    **[frida-qml](https://github.com/frida/frida-qml)**, etc.\n\n    Arguments that are **[ArrayBuffer](#arraybuffer)** objects will be substituted by\n    the result of [`hexdump()`](#hexdump) with default options.\n\n\n### Hexdump\n\n+   `hexdump(target[, options])`: generate a hexdump from the provided\n    **[ArrayBuffer](#arraybuffer)** or [NativePointer](#nativepointer) `target`,\n    optionally with `options` for customizing the output.\n\n    For example:\n\n{% highlight js %}\nconst libc = Process.getModuleByName('libc.so').base;\nconsole.log(hexdump(libc, {\n  /* address: ptr('0x1000'), -- to override the base address */\n  offset: 0,\n  length: 64,\n  header: true,\n  ansi: true\n}));\n{% endhighlight %}\n\n{% highlight sh %}\n           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF\n00000000  7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00  .ELF............\n00000010  03 00 28 00 01 00 00 00 00 00 00 00 34 00 00 00  ..(.........4...\n00000020  34 a8 04 00 00 00 00 05 34 00 20 00 08 00 28 00  4.......4. ...(.\n00000030  1e 00 1d 00 06 00 00 00 34 00 00 00 34 00 00 00  ........4...4...\n{% endhighlight %}\n\n\n### Shorthand\n\n+   `int64(v)`: short-hand for [`new Int64(v)`](#int64)\n\n+   `uint64(v)`: short-hand for [`new UInt64(v)`](#uint64)\n\n+   `ptr(s)`: short-hand for [`new NativePointer(s)`](#nativepointer)\n\n+   `NULL`: short-hand for `ptr(\"0\")`\n\n\n### Communication between host and injected process\n\n+   `recv([type, ]callback)`: request `callback` to be called on the next\n    message received from your Frida-based application. Optionally `type` may\n    be specified to only receive a message where the `type` field is set to\n    `type`.\n    {: #communication-recv}\n\n    The message is passed in the first argument, and in case binary data was\n    passed along with it, the second argument is an\n    **[ArrayBuffer](#arraybuffer)**, otherwise *null*.\n\n    This will only give you one message, so you need to call `recv()` again\n    to receive the next one.\n\n+   `send(message[, data])`: send the JavaScript object `message` to your\n    Frida-based application (it must be serializable to JSON). If you also have\n    some raw binary data that you'd like to send along with it, e.g. you dumped\n    some memory using [`NativePointer#readByteArray`](#nativepointer-readbytearray),\n    then you may pass this through the optional `data` argument. This requires it to\n    either be an **[ArrayBuffer](#arraybuffer)** or an array of integers between\n    0 and 255.\n    {: #communication-send}\n\n    <div class=\"note\">\n    <h5>Performance considerations</h5>\n    <p>\n        While <i>send()</i> is asynchronous, the total overhead of sending a single\n        message is not optimized for high frequencies, so that means Frida leaves\n        it up to you to batch multiple values into a single <i>send()</i>-call,\n        based on whether low delay or high throughput is desired.\n    </p>\n    </div>\n\n+   `rpc.exports`: empty object that you can either replace or insert into to\n    expose an RPC-style API to your application. The key specifies the method\n    name and the value is your exported function. This function may either\n    return a plain value for returning that to the caller immediately, or a\n    Promise for returning asynchronously.\n    {: #rpc-exports}\n\n>   For example:\n\n{% highlight js %}\nrpc.exports = {\n  add(a, b) {\n    return a + b;\n  },\n  sub(a, b) {\n    return new Promise(resolve => {\n      setTimeout(() => {\n        resolve(a - b);\n      }, 100);\n    });\n  }\n};\n{% endhighlight %}\n\n>   From an application using the Node.js bindings this API would be consumed\n>   like this:\n\n{% highlight js %}\nconst frida = require('frida');\nconst fs = require('fs');\nconst path = require('path');\nconst util = require('util');\n\nconst readFile = util.promisify(fs.readFile);\n\nlet session, script;\nasync function run() {\n  const source = await readFile(path.join(__dirname, '_agent.js'), 'utf8');\n  session = await frida.attach('iTunes');\n  script = await session.createScript(source);\n  script.message.connect(onMessage);\n  await script.load();\n  console.log(await script.exports.add(2, 3));\n  console.log(await script.exports.sub(5, 3));\n}\n\nrun().catch(onError);\n\nfunction onError(error) {\n  console.error(error.stack);\n}\n\nfunction onMessage(message, data) {\n  if (message.type === 'send') {\n    console.log(message.payload);\n  } else if (message.type === 'error') {\n    console.error(message.stack);\n  }\n}\n{% endhighlight %}\n\n>   The Python version would be very similar:\n\n{% highlight py %}\nimport codecs\nimport frida\n\ndef on_message(message, data):\n    if message['type'] == 'send':\n        print(message['payload'])\n    elif message['type'] == 'error':\n        print(message['stack'])\n\nsession = frida.attach('iTunes')\nwith codecs.open('./agent.js', 'r', 'utf-8') as f:\n    source = f.read()\nscript = session.create_script(source)\nscript.on('message', on_message)\nscript.load()\nprint(script.exports.add(2, 3))\nprint(script.exports.sub(5, 3))\nsession.detach()\n{% endhighlight %}\n\nIn the example above we used `script.on('message', on_message)` to monitor for\nany messages from the injected process, JavaScript side.  There are other\nnotifications that you can watch for as well on both the `script` and `session`.\nIf you want to be notified when the target process exits, use\n`session.on('detached', your_function)`.\n\n\n### Timing events\n\n+   `setTimeout(func, delay[, ...parameters])`: call `func` after `delay`\n    milliseconds, optionally passing it one or more `parameters`.\n    Returns an id that can be passed to `clearTimeout` to cancel it.\n\n+   `clearTimeout(id)`: cancel id returned by call to `setTimeout`.\n\n+   `setInterval(func, delay[, ...parameters])`: call `func` every `delay`\n    milliseconds, optionally passing it one or more `parameters`.\n    Returns an id that can be passed to `clearInterval` to cancel it.\n\n+   `clearInterval(id)`: cancel id returned by call to `setInterval`.\n\n+   `setImmediate(func[, ...parameters])`: schedules `func` to be called on\n    Frida's JavaScript thread as soon as possible, optionally passing it one\n    or more `parameters`.\n    Returns an id that can be passed to `clearImmediate` to cancel it.\n\n+   `clearImmediate(id)`: cancel id returned by call to `setImmediate`.\n\n\n### Garbage collection\n\n+   `gc()`: force garbage collection. Useful for testing, especially logic\n    involving [`Script.bindWeak()`](#bindweak).\n\n\n### Worker\n\nWorker script with its own JavaScript heap, lock, etc.\n\nThis is useful to move heavy processing to a background thread, allowing hooks\nto be handled in a timely manner.\n\n+   `new Worker(url[, options])`: creates a new worker, executing the script at\n    the specified `url`.\n\n    The URL is typically retrieved by having the module export its\n    `import.meta.url`, and importing that from the module that creates the\n    worker.\n\n    If specified, `options` is an object that may contain one or more of the\n    following keys:\n\n    -   `onMessage`: function to call when the worker emits a message using\n        **[send()](#communication-send)**. Callback signature is the same as\n        **[recv()](#communication-recv)**.\n\n-   `terminate()`: terminates the worker.\n\n-   `post(message[, data])`: posts a message to the worker. Signature is\n    identical to **[send()](#communication-send)**. Use\n    **[recv()](#communication-recv)** to receive it inside the worker.\n\n-   `exports`: magic proxy object for calling **[rpc.exports](#rpc-exports)**\n    defined by the worker. Each function returns a *Promise*, which you may\n    *await* inside an *async* function.\n\n\n### Cloak\n\nKeeps you from seeing yourself during process introspection.\n\nIntrospection APIs such as\n[`Process.enumerateThreads()`](#process-enumeratethreads) ensure that cloaked\nresources are skipped, and things appear as if you were not inside the process\nbeing instrumented.\n\nAny resources created by Frida's runtime will be cloaked automatically. This\nmeans you typically only need to manage cloaked resources if you use an\nOS-specific API to create a given resource.\n\n+   `Cloak.addThread(id)`: updates the registry of cloaked resources so the\n    given thread `id` becomes invisible to cloak-aware APIs, such as\n    [`Process.enumerateThreads()`](#process-enumeratethreads).\n\n+   `Cloak.removeThread(id)`: updates the registry of cloaked resources so the\n    given thread `id` becomes visible to cloak-aware APIs, such as\n    [`Process.enumerateThreads()`](#process-enumeratethreads).\n\n+   `Cloak.hasCurrentThread()`: returns a boolean indicating whether the current\n    thread is currently being cloaked.\n\n+   `Cloak.hasThread(id)`: returns a boolean indicating whether the given thread\n    `id` is currently being cloaked.\n\n+   `Cloak.addRange(range)`: updates the registry of cloaked resources so the\n    given memory `range` becomes invisible to cloak-aware APIs, such as\n    [`Process.enumerateRanges()`](#process-enumerateranges).\n    The provided `range` is an object with `base` and `size` properties – like\n    the properties in an object returned by e.g.\n    [`Process.getModuleByName()`](#process-getmodulebyname).\n    {: #cloak-addrange}\n\n+   `Cloak.removeRange(range)`: updates the registry of cloaked resources so the\n    given memory `range` becomes visible to cloak-aware APIs, such as.\n    [`Process.enumerateRanges()`](#process-enumerateranges).\n    The provided `range` is an object with `base` and `size` properties – like\n    the properties in an object returned by e.g.\n    [`Process.getModuleByName()`](#process-getmodulebyname).\n\n+   `Cloak.hasRangeContaining(address)`: returns a boolean indicating whether a\n    memory range containing `address` is currently cloaked, specified as a\n    [NativePointer](#nativepointer).\n\n+   `Cloak.clipRange(range)`: determines how much of the given memory `range` is\n    currently visible. The provided `range` is an object with `base` and `size`\n    properties – like the properties in an object returned by e.g.\n    [`Process.getModuleByName()`](#process-getmodulebyname). Returns an array of\n    such objects, indicating the visible parts of `range`. Will return an empty\n    array if the entire range is cloaked, or `null` if it is entirely visible.\n\n+   `Cloak.addFileDescriptor(fd)`: updates the registry of cloaked resources so\n    the given file descriptor `fd` becomes invisible to cloak-aware APIs.\n\n+   `Cloak.removeFileDescriptor(fd)`: updates the registry of cloaked resources\n    so the given file descriptor  `fd` becomes visible to cloak-aware APIs.\n\n+   `Cloak.hasFileDescriptor(fd)`: returns a boolean indicating whether the\n    given file descriptor `fd` is currently being cloaked.\n\n\n### Profiler\n\nSimple worst-case profiler built on top of `Interceptor`.\n\nUnlike a conventional profiler, which samples call stacks at a certain\nfrequency, you decide the exact functions that you're interested in profiling.\n\nWhen any of those functions gets called, the profiler grabs a sample on entry,\nand another one upon return. It then subtracts the two, to compute how expensive\nthe call was. If the resulting value is greater than what it's seen previously\nfor the specific function, that value becomes its new worst-case.\n\nWhenever a new worst-case has been discovered, it isn't necessarily enough to\nknow that most of the time/cycles/etc. was spent by a specific function. That\nfunction may only be slow with certain input arguments, for example.\n\nThis is a situation where you can pass in a [`describe`](#profiler-describe)\ncallback for the specific function. Your callback should capture relevant\ncontext from the argument list and/or other state, and return a string that\ndescribes the new worst-case that was just discovered.\n\nWhen you later decide to call `generateReport()`, you'll find your computed\ndescriptions embedded in each worst-case entry.\n\n+   `new Profiler()`: creates a Profiler.\n\n-   `instrument(functionAddress, sampler[, callbacks])`: starts instrumenting\n    the specified function, specified by the `functionAddress`\n    [`NativePointer`](#nativepointer), using [`sampler`](#sampler).\n\n    The optional `callbacks` argument is an object that may contain:\n\n    -   `describe(args)`: called synchronously when a new worst-case has been\n        discovered, and a description should be captured from the argument list\n        and/or other relevant state. The implementation must return a string\n        describing the argument list. For more details about `args` and how\n        `this` is bound, see Interceptor [`onEnter`](#interceptor-onenter).\n        {: #profiler-describe}\n\n-   `generateReport()`: generates an XML report from the live profiler state,\n    returned as a string. May be called at any point, and as many times as\n    desired.\n\n\n### Sampler\n\n-   `sample()`: retrieves a new sample, returned as a bigint. What it denotes\n    depends on the specific sampler.\n\n\n### CycleSampler\n\nSampler that measures CPU cycles, e.g. using the RDTSC instruction on x86.\n\n+   `new CycleSampler()`: creates a CycleSampler.\n\n\n### BusyCycleSampler\n\nSampler that measures CPU cycles only spent by the current thread, e.g. using\nQueryThreadCycleTime() on Windows.\n\n+   `new BusyCycleSampler()`: creates a BusyCycleSampler.\n\n\n### WallClockSampler\n\nSampler that measures passage of time.\n\n+   `new WallClockSampler()`: creates a WallClockSampler.\n\n\n### UserTimeSampler\n\nSampler that measures time spent in user-space.\n\n+   `new UserTimeSampler([threadId])`: creates a UserTimeSampler that samples\n    the thread specified by `threadId`, as a number, or the current thread if\n    omitted.\n\n\n### MallocCountSampler\n\nSampler that counts the number of calls to malloc(), calloc(), and realloc().\n\n+   `new MallocCountSampler()`: creates a MallocCountSampler.\n\n\n### CallCountSampler\n\nSampler that counts the number of calls to functions of your choosing.\n\n+   `new CallCountSampler(functions)`: creates a CallCountSampler that samples\n    the number of calls to `functions`, an array of\n    [`NativePointer`](#nativepointer) values specifying the functions to\n    count the number of calls to.\n\n\n[r2]: https://radare.org/r/",
      "keywords": [
        "console.log",
        "console.warn",
        "console.error",
        "hexdump",
        "Process.getModuleByName",
        "ptr",
        "int64",
        "Int64",
        "uint64",
        "UInt64",
        "NativePointer",
        "recv",
        "send",
        "application",
        "add",
        "sub",
        "Promise",
        "setTimeout",
        "resolve",
        "require",
        "util.promisify",
        "run",
        "readFile",
        "path.join",
        "frida.attach",
        "session.createScript",
        "script.message.connect",
        "script.load",
        "script.exports.add",
        "script.exports.sub",
        "catch",
        "onError",
        "onMessage",
        "if",
        "on_message",
        "print",
        "codecs.open",
        "f.read",
        "session.create_script",
        "script.on",
        "session.detach",
        "session.on",
        "clearTimeout",
        "setInterval",
        "clearInterval",
        "setImmediate",
        "clearImmediate",
        "gc",
        "Script.bindWeak",
        "Worker"
      ],
      "examples": []
    },
    {
      "id": "frida17-migration",
      "title": "Frida 17 Migration Guide",
      "category": "Migration",
      "content": "## Frida 17 Migration Guide\n\n### Breaking Changes in Frida 17\n\n#### Module static methods removed\n`Module.findExportByName(module, name)` → `Process.getModuleByName(module).getExportByName(name)`\n`Module.enumerateExports(module)` → `Process.getModuleByName(module).enumerateExports()`\n`Module.findBaseAddress(module)` → `Process.getModuleByName(module).base`\n`Module.getBaseAddress(module)` → `Process.getModuleByName(module).base`\n\n#### Memory static read/write methods removed\n`Memory.readU8(ptr)` → `ptr.readU8()`\n`Memory.readU16(ptr)` → `ptr.readU16()`\n`Memory.readU32(ptr)` → `ptr.readU32()`\n`Memory.readU64(ptr)` → `ptr.readU64()`\n`Memory.readPointer(ptr)` → `ptr.readPointer()`\n`Memory.readByteArray(ptr, len)` → `ptr.readByteArray(len)`\n`Memory.readUtf8String(ptr)` → `ptr.readUtf8String()`\n`Memory.readUtf16String(ptr)` → `ptr.readUtf16String()`\n`Memory.writeU8(ptr, val)` → `ptr.writeU8(val)`\n`Memory.writeU16(ptr, val)` → `ptr.writeU16(val)`\n`Memory.writeU32(ptr, val)` → `ptr.writeU32(val)`\n`Memory.writeU64(ptr, val)` → `ptr.writeU64(val)`\n`Memory.writePointer(ptr, val)` → `ptr.writePointer(val)`\n`Memory.writeByteArray(ptr, arr)` → `ptr.writeByteArray(arr)`\n`Memory.writeUtf8String(ptr, str)` → `ptr.writeUtf8String(str)`\n`Memory.writeUtf16String(ptr, str)` → `ptr.writeUtf16String(str)`\n\n#### Callback-style enumeration removed\n`Process.enumerateModules({ onMatch, onComplete })` → `Process.enumerateModules()` (returns array)\n`Module.enumerateExports({ onMatch, onComplete })` → `mod.enumerateExports()` (returns array)\n`Module.enumerateRanges({ onMatch, onComplete })` → `mod.enumerateRanges(prot)` (returns array)\nThe `*Sync` variants are also removed — the non-Sync versions now return arrays directly.\n\n#### Module.findExportByName instance method\nUse `Process.findModuleByName(name)` first, then call `.getExportByName(sym)` on the result:\n```js\nvar mod = Process.getModuleByName(\"libc.so\");\nvar addr = mod.getExportByName(\"open\");\n```\n\n#### hexdump is a global built-in\nDo NOT define your own `function hexdump()` — it shadows the built-in Frida `hexdump(target, options)`.\nUse a different name like `dumpHex()` if you need a custom implementation.\n\n### Project-Specific Pitfalls (TikTok X-Argus)\n- `g2.LIZ.value` returns `undefined` for primitive `long` — use reflection: `f.getLong(instance)`\n- `DmtSec.frameSign` is an INSTANCE method on a Kotlin singleton — `Java.use()` can't call it as static\n- Use `Java.choose('ms.bd.o.g2')` to find live instances (bypasses Kotlin wrapper issues)\n- Hook base64 at `0x13c7e8` only when `insideFrameSign=true` to avoid crashes during init\n- The base64 encoder at `0x13c7e8` takes 5 args (x0-x4), returns int, NOT pointer\n",
      "keywords": [
        "Module.findExportByName",
        "Memory.readU32",
        "Memory.readPointer",
        "Memory.writeU32",
        "enumerateModulesSync",
        "enumerateExportsSync",
        "deprecated",
        "migration",
        "breaking",
        "removed",
        "frida17",
        "hexdump",
        "getLong",
        "DmtSec",
        "g2"
      ],
      "examples": [
        "// Old (Frida 16):\nvar addr = Module.findExportByName(\"libc.so\", \"open\");\n\n// New (Frida 17):\nvar mod = Process.getModuleByName(\"libc.so\");\nvar addr = mod.getExportByName(\"open\");",
        "// Old (Frida 16):\nvar val = Memory.readU32(ptr(\"0x1234\"));\n\n// New (Frida 17):\nvar val = ptr(\"0x1234\").readU32();"
      ]
    }
  ]
}